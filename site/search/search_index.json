{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"tables_ref/","title":"I got the meat, Jack","text":""},{"location":"tables_ref/#demographics","title":"Demographics","text":"<p>             Bases: <code>Tables</code></p> <p>Sets up a table for a given timeframe Parameters:</p> <pre><code>t1: start date, formatted as \"YYYY-MM-DD\"\nt2: end date, formatted as \"YYYY-MM-DD\"\nprint_sql (Bool): whether to print the SQL statements when run, defaults to True\nclipboard (Bool): whether to copy the output table to your clipboard, defaults to False\ndefault_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>class Queries(Tables):\n'''\n    Sets up a table for a given timeframe\n    Parameters:\n\n        t1: start date, formatted as \"YYYY-MM-DD\"\n        t2: end date, formatted as \"YYYY-MM-DD\"\n        print_sql (Bool): whether to print the SQL statements when run, defaults to True\n        clipboard (Bool): whether to copy the output table to your clipboard, defaults to False\n        default_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n    '''\n    def dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n        Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n\n        Parameters:\n\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n            age: threshold at which a client is counted as a juvenile, defaults to 18\n            cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n\n\n        SQL Equivalent:\n\n            select \n                count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n            from stints.classify_by_program\n            join civicore.participants using(participant_id);'''\n        if cutoff_date.lower() == \"t1\":\n            cutoff_date = self.t1\n        if cutoff_date.lower()  == \"t2\":\n            cutoff_date = self.t2\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        if tally is True:\n            query = f'''select \n                count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n                from {self.table}\n                join civicore.participants using(participant_id)'''\n        else: \n            query = f'''select \n                l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n                from {self.table} l\n                join civicore.participants using(participant_id)'''\n        modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n        if new_clients is True:\n            query = self.query_modify(str(query), modifier)\n        df = self.query_run(query)\n        return(df)\n\n    def dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n        Returns a count of client races or genders\n\n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            race_gender: the category to tally, enter either \"race\" or \"gender\"\n\n\n        SQL Equivalent:\n\n            select race, count(distinct participant_id)\n            from stints.classify_by_program\n            join civicore.participants using(participant_id)\n            group by race;\n        '''\n        query = f'''select {race_gender}, count(distinct participant_id)\n        from {self.table}\n        join civicore.participants using(participant_id)\n        group by {race_gender}'''\n        modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n        if new_clients is True:\n            query = self.query_modify(str(query), modifier)  # Use self.query_modify here\n        df = self.query_run(query)\n        return(df)\n\n    def dem_recent_address(self):\n'''\n        Finds the recent addresses of clients\n\n\n        SQL Equivalent:\n\n            with ranked_addresses as\n                (select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id \n                    ORDER BY primary_address DESC, entered_date DESC) AS rn \n                from stints.classify_by_program\n                join civicore.address a using(participant_id))\n\n                select * from ranked_addresses\n                where rn = 1\n                    ;\n        '''\n        query = f'''with ranked_addresses as(select first_name, last_name, a.*,\n                ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n                join civicore.address a using(participant_id))\n                select * from ranked_addresses\n                where rn = 1\n                '''\n        df = self.query_run(query)\n        return(df)\n\n    def docs_has_formatted(self):\n'''\n        checks if clients have ISPs or Assessments and if they are formatted correctly\n        '''\n        query = f'''SELECT DISTINCT (participant_id), ASSM_ISP_formatted, has_ASSM_ISP, FCS_formatted, has_FCS,  BP_formatted, has_BP, PCL_formatted, has_PCL,  has_cdc, assess\nFROM (select * from {self.table}) cr\nLEFT JOIN( select participant_id, first_name, last_name\nfrom civicore.participants) p USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_ASSM_ISP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS ASSM_ISP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_ASSM_ISP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*'\nGROUP BY participant_id, Has_ASSM_ISP\n) assm USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_FCS_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS FCS_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*FCS.*|.*Crime.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_FCS\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*FCS.*|.*Crime.*'\nGROUP BY participant_id, has_FCS\n) fcs USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_BP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS BP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*BP.*|.*Buss.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_BP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*BP.*|.*Buss.*'\nGROUP BY participant_id, has_BP\n) bp USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_PCL_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS PCL_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_PCL\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*'\nGROUP BY participant_id, has_PCL\n) PCL USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_CDC_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS CDC_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_CDC\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*'\nGROUP BY participant_id, has_CDC\n) cdc USING (participant_id)\nleft join(\nselect participant_id,\n        COUNT(CASE\n                WHEN d.document_type = 'Assessments' THEN 1 ELSE NULL END) as assess\n from documents.unfiltered d\n group by participant_id) asseses USING (participant_id);'''\n        df = self.query_run(query)\n        return df\n\n\n    def legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n\n\n        SQL Equivalent:\n\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\n        query = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\n        if pending is True:\n            query = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\n        df = self.query_run(query)\n        return df\n\n    def legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n\n\n        SQL Equivalent:\n\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\n        if cutoff_date.lower() == \"t1\":\n            cutoff_date = self.t1\n        if cutoff_date.lower()  == \"t2\":\n            cutoff_date = self.t2\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        if tally is True: \n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\n        else:\n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\n        df = self.query_run(query)\n        return df\n\n    def legal_lclc_involvement(self):\n'''\n        returns linkage and case session tallies for clients with cases ended in a timeframe\n\n\n        SQL Equivalent:\n\n            with outcomes as (select participant_id, charge, case_type,\n                case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n                (select * from \n                    (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                    GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)) d),\n            links as (select participant_id,\n                count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n                count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n                from civicore.linkages\n                where hub_initiated = \"yes\"\n                group by participant_id),\n            sessions as (select participant_id,\n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n            group by participant_id)\n            select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n            left join links l on o.participant_id = l.participant_id\n            left join sessions s on o.participant_id = s.participant_id;\n        '''\n        query = f'''with outcomes as (select participant_id, charge, case_type,\n    case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)) d),\nlinks as (select participant_id,\ncount(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\ncount(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\nfrom civicore.linkages\nwhere hub_initiated = \"yes\"\ngroup by participant_id),\nsessions as (select participant_id,\n        COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\ngroup by participant_id)\n\nselect o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\nleft join links l on o.participant_id = l.participant_id\nleft join sessions s on o.participant_id = s.participant_id'''\n        df = self.query_run(query)\n        df = df.fillna(0)\n        df['order'] = df.groupby('participant_id').cumcount() + 1\n        pivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\n        pivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\n        max_cases = df['order'].max()\n\n        case_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\n        case_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\n        other_columns = [col for col in pivoted_df.columns if col not in case_columns]\n        pivoted_df = pivoted_df[case_columns + other_columns]\n        pivoted_df = pivoted_df.reset_index()\n        if self.clipboard is True:\n            pivoted_df.to_clipboard()\n        return pivoted_df\n\n    def legal_fel_reduction(self, timeframe = True):\n'''\n        Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            select felony, count(felony) FROM \n                (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                    ELSE 'remained' \n                END AS felony from\n                    (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                            CASE\n                                WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                                ELSE 'Not Lower'\n                            END AS rank_comparison from civicore.legal lt \n                            join stints.classify_by_program using(participant_id) \n                            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                        GROUP BY participant_id) j\n                    ) k \n                group by felony;\n        '''\n        if timeframe is True: \n            query = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n            GROUP BY participant_id) j) k group by felony;'''\n        else:\n            query = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL) h \n            GROUP BY participant_id) j) k group by felony;'''\n        df = self.query_run(query)\n        return df\n\n    def legal_case_outcomes(self,  timeframe = True):\n'''\n        returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            with ranked_df as \n            (select * from \n                (SELECT participant_id, case_outcome, \n                GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n                GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                    (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)),\n            plea_concat as \n                (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n                else case_outcome end as case_outcome\n            from (select case_outcome, sentence from ranked_df d1\n            LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n            WHERE d2.ranking IS NULL)h)\n            select case_outcome, count(case_outcome) from plea_concat\n            group by case_outcome\n        '''\n        if timeframe is True: \n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome\n        '''\n        else: \n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id)) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome'''\n        df = self.query_run(query)\n        return df  \n\n    def legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n\n\n        SQL Equivalent:\n\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n\n        '''\n\n        if timeframe is False:\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                relevant_date = \"arrest_date\"\n            else:\n                relevant_date = \"case_outcome_date\"\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Found Guilty' then 4\nelse 5\nend asc'''\n        df = self.query_run(query)\n        return df\n\n    def legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \n        if timeframe is True:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        else:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        df = self.query_run(query)\n        return df\n\n    def legal_case_type(self, timeframe = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n\n\n        SQL Equivalent:\n\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\n        if case_client == \"case\":\n            case_client = \"case_id\"\n        if case_client ==\"client\":\n            case_client = \"participant_id\"     \n        query = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                opened_closed = \"arrest_date\"\n                query = self.query_modify(str(query), f'''and (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\n            else:\n                opened_closed = \"case_outcome_date\"\n                query = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \n        df = self.query_run(query)\n        if percentage is True:\n            df = self.percentage_convert(df, replace= False)\n        return df   \n\n    def legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n\n\n        SQL Equivalent:\n\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\n        query = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\n        df = self.query_run(query)\n        return df\n\n\n    def legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\n        if t1_t2 == \"t1\": \n            t1_t2 = self.q_t1\n        else:\n            t1_t2 = self.q_t2\n        if also_ended == False:\n            query = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\n            df = self.query_run(query)\n            return df\n        else:\n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\n\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\n\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\n        df = self.query_run(query)\n        return df\n\n    def legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n\n        SQL Equivalent:\n\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\n        query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\n        if timeframe is True:\n            query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \n        df = self.query_run(query)\n        return df\n\n    def link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n        Returns the number of clients with at least one linkage\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from \n                (select participant_id from stints.classify_by_program) x \n            join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n        '''\n        query = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\n        if hub_initiated is False and timeframe is False:\n            df = self.query_run(query)\n            return df\n        if started_linked.lower() == \"both\":\n            if hub_initiated is False:\n                query = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\n            if hub_initiated is True:\n                query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\n        if hub_initiated is True and timeframe is False:\n            query = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\n        else:\n            if hub_initiated is False and timeframe is True:\n                query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n            if hub_initiated is True and timeframe is True:\n                query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\n        df = self.query_run(query)\n        return df\n\n    def link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\n        if cutoff_date == \"t1\":\n            cutoff_date = self.t1\n        if link_type.lower() == \"education\":\n            inequality_sign = '&lt;'\n        if link_type.lower() == \"employment\":\n            inequality_sign = '&gt;'\n        link_type = f\"'{link_type}'\"\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        query = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\n        if hub_initiated == True:\n            query = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\n        if first_n_months is not None:\n            query = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\n        df = self.query_run(query)\n        return df\n\n    def link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n        SQL Equivalent:\n\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\n\n        query = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\n        if timeframe == True:\n            if started_linked == \"linked_date\" or started_linked == \"start_date\":\n                query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n            if started_linked == \"both\" or started_linked == \"Both\":\n                query = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\n            if hub_initiated == True:\n                query = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\n        if timeframe == False and hub_initiated == True:\n            query = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\n        df = self.query_run(query)\n        return df\n\n    def programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n\n\n        SQL Equivalent:\n\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n\n        '''\n        query = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\n\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\n\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\n        df = self.query_run(query)\n        return df\n\n    def programs_grant_tally(self, start_end = None):\n'''\n        Tallies the number of grants in a timeframe\n\n        Parameters:\n            start_end: optional, to find the number of grants started or ended use \"start_date\" or \"end_date\"\n\n\n        SQL Equivalent:\n\n            select grant_type, count(distinct participant_id) from stints.classify_by_program group by grant_type;\n        '''\n        query = f'''select grant_type, count(distinct participant_id) from {self.table} group by grant_type'''\n        if start_end == \"start_date\":\n            query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or active_date between {self.q_t1} and {self.q_t2}''')\n        elif start_end == \"end_date\":\n            query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or closed_date between {self.q_t1} and {self.q_t2}''')\n        df = self.query_run(query)\n        return df\n\n    def programs_service_tally(self, service_column):\n'''\n        Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n\n        Parameters:\n            Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n\n\n        SQL Equivalent: \n\n            select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n        '''\n        if service_column.lower() == \"outreach\":\n            query = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\n        else:\n            query = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\n\n        df = self.query_run(query)\n        return df\n\n\n    def programs_had_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n        Counts clients who have at least one recorded session with a case manager or outreach worker\n\n        Parameters:\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n        SQL Equivalent: \n\n            select count(distinct participant_id) from stints.classify_by_program \n            join civicore.case_sessions using(participant_id) \n            where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\n        if cm_outreach.lower() == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach.lower() == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        query = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n        if timeframe is True:\n            query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n        df = self.query_run(query)\n        return df\n\n    def programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n        SQL Equivalent:\n\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\n        if cm_outreach.lower() == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach.lower() == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        query = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\n        df = self.query_run(query)\n        return df\n\n    def programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n\n        SQL Equivalent:\n\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\n        if demographic == \"age\" and self.joined_participants == False:\n            query = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\n        else:\n            query = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\n        print(self.table)\n        if self.joined_participants == False and demographic != \"age\":\n            query = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\n        df = self.query_run(query)\n        if percentages == True:\n            df = self.percentage_convert(df)\n        return df\n\n    def programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n        Finds the length of case management or outreach sessions\n\n        Parameters:\n            cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n            grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n\n        SQL Equivalent:\n\n            select \n                avg(hours) * 60 as overall,\n                avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\n        if cm_outreach == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        if grouped is False:\n            query = f'''select \n            avg(hours) * 60 as overall,\n         avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n            if timeframe is True:\n                query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n        if grouped is True:\n            if timeframe is True:  \n                query = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\n\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\n            else: \n                query = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_casenote = {cm_outreach})\n\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\n        df = self.query_run(query)\n        return df\n\n    def programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n\n        SQL Equivalent:\n\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\n        query = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.dem_age","title":"dem_age","text":"<pre><code>dem_age(new_clients=False, tally=True, age=18, cutoff_date='active_date')\n</code></pre> <p>Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults </p> <p>Parameters:</p> <pre><code>new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\ntally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\nage: threshold at which a client is counted as a juvenile, defaults to 18\ncutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n</code></pre> <p>SQL Equivalent:</p> <pre><code>select \n    count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n    count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\nfrom stints.classify_by_program\njoin civicore.participants using(participant_id);\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n    Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n\n    Parameters:\n\n        new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n        tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n        age: threshold at which a client is counted as a juvenile, defaults to 18\n        cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n\n\n    SQL Equivalent:\n\n        select \n            count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n            count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n        from stints.classify_by_program\n        join civicore.participants using(participant_id);'''\n    if cutoff_date.lower() == \"t1\":\n        cutoff_date = self.t1\n    if cutoff_date.lower()  == \"t2\":\n        cutoff_date = self.t2\n    if cutoff_date.lower() != \"active_date\":\n        cutoff_date = f'\"{cutoff_date}\"'\n    if tally is True:\n        query = f'''select \n            count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n            count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n            from {self.table}\n            join civicore.participants using(participant_id)'''\n    else: \n        query = f'''select \n            l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n            from {self.table} l\n            join civicore.participants using(participant_id)'''\n    modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n    if new_clients is True:\n        query = self.query_modify(str(query), modifier)\n    df = self.query_run(query)\n    return(df)\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.dem_race_gender","title":"dem_race_gender","text":"<pre><code>dem_race_gender(new_clients=False, race_gender=None)\n</code></pre> <p>Returns a count of client races or genders</p> <p>Parameters:</p> Name Type Description Default <code>new_clients</code> <code>Bool</code> <p>if true, only counts clients who began between t1 and t2. defaults to False</p> <code>False</code> <code>race_gender</code> <p>the category to tally, enter either \"race\" or \"gender\"</p> <code>None</code> <p>SQL Equivalent:</p> <pre><code>select race, count(distinct participant_id)\nfrom stints.classify_by_program\njoin civicore.participants using(participant_id)\ngroup by race;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n    Returns a count of client races or genders\n\n    Parameters:\n        new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n        race_gender: the category to tally, enter either \"race\" or \"gender\"\n\n\n    SQL Equivalent:\n\n        select race, count(distinct participant_id)\n        from stints.classify_by_program\n        join civicore.participants using(participant_id)\n        group by race;\n    '''\n    query = f'''select {race_gender}, count(distinct participant_id)\n    from {self.table}\n    join civicore.participants using(participant_id)\n    group by {race_gender}'''\n    modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n    if new_clients is True:\n        query = self.query_modify(str(query), modifier)  # Use self.query_modify here\n    df = self.query_run(query)\n    return(df)\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.dem_recent_address","title":"dem_recent_address","text":"<pre><code>dem_recent_address()\n</code></pre> <p>Finds the recent addresses of clients</p> <p>SQL Equivalent:</p> <pre><code>with ranked_addresses as\n    (select first_name, last_name, a.*,\n        ROW_NUMBER() OVER (partition by participant_id \n        ORDER BY primary_address DESC, entered_date DESC) AS rn \n    from stints.classify_by_program\n    join civicore.address a using(participant_id))\n\n    select * from ranked_addresses\n    where rn = 1\n        ;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def dem_recent_address(self):\n'''\n    Finds the recent addresses of clients\n\n\n    SQL Equivalent:\n\n        with ranked_addresses as\n            (select first_name, last_name, a.*,\n                ROW_NUMBER() OVER (partition by participant_id \n                ORDER BY primary_address DESC, entered_date DESC) AS rn \n            from stints.classify_by_program\n            join civicore.address a using(participant_id))\n\n            select * from ranked_addresses\n            where rn = 1\n                ;\n    '''\n    query = f'''with ranked_addresses as(select first_name, last_name, a.*,\n            ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n            join civicore.address a using(participant_id))\n            select * from ranked_addresses\n            where rn = 1\n            '''\n    df = self.query_run(query)\n    return(df)\n</code></pre>"},{"location":"tables_ref/#legal","title":"Legal","text":"<p>             Bases: <code>Tables</code></p> <p>Sets up a table for a given timeframe Parameters:</p> <pre><code>t1: start date, formatted as \"YYYY-MM-DD\"\nt2: end date, formatted as \"YYYY-MM-DD\"\nprint_sql (Bool): whether to print the SQL statements when run, defaults to True\nclipboard (Bool): whether to copy the output table to your clipboard, defaults to False\ndefault_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>class Queries(Tables):\n'''\n    Sets up a table for a given timeframe\n    Parameters:\n\n        t1: start date, formatted as \"YYYY-MM-DD\"\n        t2: end date, formatted as \"YYYY-MM-DD\"\n        print_sql (Bool): whether to print the SQL statements when run, defaults to True\n        clipboard (Bool): whether to copy the output table to your clipboard, defaults to False\n        default_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n    '''\n    def dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n        Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n\n        Parameters:\n\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n            age: threshold at which a client is counted as a juvenile, defaults to 18\n            cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n\n\n        SQL Equivalent:\n\n            select \n                count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n            from stints.classify_by_program\n            join civicore.participants using(participant_id);'''\n        if cutoff_date.lower() == \"t1\":\n            cutoff_date = self.t1\n        if cutoff_date.lower()  == \"t2\":\n            cutoff_date = self.t2\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        if tally is True:\n            query = f'''select \n                count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n                from {self.table}\n                join civicore.participants using(participant_id)'''\n        else: \n            query = f'''select \n                l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n                from {self.table} l\n                join civicore.participants using(participant_id)'''\n        modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n        if new_clients is True:\n            query = self.query_modify(str(query), modifier)\n        df = self.query_run(query)\n        return(df)\n\n    def dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n        Returns a count of client races or genders\n\n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            race_gender: the category to tally, enter either \"race\" or \"gender\"\n\n\n        SQL Equivalent:\n\n            select race, count(distinct participant_id)\n            from stints.classify_by_program\n            join civicore.participants using(participant_id)\n            group by race;\n        '''\n        query = f'''select {race_gender}, count(distinct participant_id)\n        from {self.table}\n        join civicore.participants using(participant_id)\n        group by {race_gender}'''\n        modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n        if new_clients is True:\n            query = self.query_modify(str(query), modifier)  # Use self.query_modify here\n        df = self.query_run(query)\n        return(df)\n\n    def dem_recent_address(self):\n'''\n        Finds the recent addresses of clients\n\n\n        SQL Equivalent:\n\n            with ranked_addresses as\n                (select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id \n                    ORDER BY primary_address DESC, entered_date DESC) AS rn \n                from stints.classify_by_program\n                join civicore.address a using(participant_id))\n\n                select * from ranked_addresses\n                where rn = 1\n                    ;\n        '''\n        query = f'''with ranked_addresses as(select first_name, last_name, a.*,\n                ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n                join civicore.address a using(participant_id))\n                select * from ranked_addresses\n                where rn = 1\n                '''\n        df = self.query_run(query)\n        return(df)\n\n    def docs_has_formatted(self):\n'''\n        checks if clients have ISPs or Assessments and if they are formatted correctly\n        '''\n        query = f'''SELECT DISTINCT (participant_id), ASSM_ISP_formatted, has_ASSM_ISP, FCS_formatted, has_FCS,  BP_formatted, has_BP, PCL_formatted, has_PCL,  has_cdc, assess\nFROM (select * from {self.table}) cr\nLEFT JOIN( select participant_id, first_name, last_name\nfrom civicore.participants) p USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_ASSM_ISP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS ASSM_ISP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_ASSM_ISP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*'\nGROUP BY participant_id, Has_ASSM_ISP\n) assm USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_FCS_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS FCS_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*FCS.*|.*Crime.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_FCS\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*FCS.*|.*Crime.*'\nGROUP BY participant_id, has_FCS\n) fcs USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_BP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS BP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*BP.*|.*Buss.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_BP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*BP.*|.*Buss.*'\nGROUP BY participant_id, has_BP\n) bp USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_PCL_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS PCL_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_PCL\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*'\nGROUP BY participant_id, has_PCL\n) PCL USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_CDC_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS CDC_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_CDC\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*'\nGROUP BY participant_id, has_CDC\n) cdc USING (participant_id)\nleft join(\nselect participant_id,\n        COUNT(CASE\n                WHEN d.document_type = 'Assessments' THEN 1 ELSE NULL END) as assess\n from documents.unfiltered d\n group by participant_id) asseses USING (participant_id);'''\n        df = self.query_run(query)\n        return df\n\n\n    def legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n\n\n        SQL Equivalent:\n\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\n        query = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\n        if pending is True:\n            query = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\n        df = self.query_run(query)\n        return df\n\n    def legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n\n\n        SQL Equivalent:\n\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\n        if cutoff_date.lower() == \"t1\":\n            cutoff_date = self.t1\n        if cutoff_date.lower()  == \"t2\":\n            cutoff_date = self.t2\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        if tally is True: \n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\n        else:\n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\n        df = self.query_run(query)\n        return df\n\n    def legal_lclc_involvement(self):\n'''\n        returns linkage and case session tallies for clients with cases ended in a timeframe\n\n\n        SQL Equivalent:\n\n            with outcomes as (select participant_id, charge, case_type,\n                case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n                (select * from \n                    (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                    GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)) d),\n            links as (select participant_id,\n                count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n                count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n                from civicore.linkages\n                where hub_initiated = \"yes\"\n                group by participant_id),\n            sessions as (select participant_id,\n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n            group by participant_id)\n            select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n            left join links l on o.participant_id = l.participant_id\n            left join sessions s on o.participant_id = s.participant_id;\n        '''\n        query = f'''with outcomes as (select participant_id, charge, case_type,\n    case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)) d),\nlinks as (select participant_id,\ncount(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\ncount(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\nfrom civicore.linkages\nwhere hub_initiated = \"yes\"\ngroup by participant_id),\nsessions as (select participant_id,\n        COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\ngroup by participant_id)\n\nselect o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\nleft join links l on o.participant_id = l.participant_id\nleft join sessions s on o.participant_id = s.participant_id'''\n        df = self.query_run(query)\n        df = df.fillna(0)\n        df['order'] = df.groupby('participant_id').cumcount() + 1\n        pivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\n        pivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\n        max_cases = df['order'].max()\n\n        case_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\n        case_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\n        other_columns = [col for col in pivoted_df.columns if col not in case_columns]\n        pivoted_df = pivoted_df[case_columns + other_columns]\n        pivoted_df = pivoted_df.reset_index()\n        if self.clipboard is True:\n            pivoted_df.to_clipboard()\n        return pivoted_df\n\n    def legal_fel_reduction(self, timeframe = True):\n'''\n        Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            select felony, count(felony) FROM \n                (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                    ELSE 'remained' \n                END AS felony from\n                    (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                            CASE\n                                WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                                ELSE 'Not Lower'\n                            END AS rank_comparison from civicore.legal lt \n                            join stints.classify_by_program using(participant_id) \n                            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                        GROUP BY participant_id) j\n                    ) k \n                group by felony;\n        '''\n        if timeframe is True: \n            query = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n            GROUP BY participant_id) j) k group by felony;'''\n        else:\n            query = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL) h \n            GROUP BY participant_id) j) k group by felony;'''\n        df = self.query_run(query)\n        return df\n\n    def legal_case_outcomes(self,  timeframe = True):\n'''\n        returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            with ranked_df as \n            (select * from \n                (SELECT participant_id, case_outcome, \n                GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n                GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                    (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)),\n            plea_concat as \n                (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n                else case_outcome end as case_outcome\n            from (select case_outcome, sentence from ranked_df d1\n            LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n            WHERE d2.ranking IS NULL)h)\n            select case_outcome, count(case_outcome) from plea_concat\n            group by case_outcome\n        '''\n        if timeframe is True: \n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome\n        '''\n        else: \n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id)) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome'''\n        df = self.query_run(query)\n        return df  \n\n    def legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n\n\n        SQL Equivalent:\n\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n\n        '''\n\n        if timeframe is False:\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                relevant_date = \"arrest_date\"\n            else:\n                relevant_date = \"case_outcome_date\"\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Found Guilty' then 4\nelse 5\nend asc'''\n        df = self.query_run(query)\n        return df\n\n    def legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \n        if timeframe is True:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        else:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        df = self.query_run(query)\n        return df\n\n    def legal_case_type(self, timeframe = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n\n\n        SQL Equivalent:\n\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\n        if case_client == \"case\":\n            case_client = \"case_id\"\n        if case_client ==\"client\":\n            case_client = \"participant_id\"     \n        query = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                opened_closed = \"arrest_date\"\n                query = self.query_modify(str(query), f'''and (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\n            else:\n                opened_closed = \"case_outcome_date\"\n                query = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \n        df = self.query_run(query)\n        if percentage is True:\n            df = self.percentage_convert(df, replace= False)\n        return df   \n\n    def legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n\n\n        SQL Equivalent:\n\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\n        query = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\n        df = self.query_run(query)\n        return df\n\n\n    def legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\n        if t1_t2 == \"t1\": \n            t1_t2 = self.q_t1\n        else:\n            t1_t2 = self.q_t2\n        if also_ended == False:\n            query = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\n            df = self.query_run(query)\n            return df\n        else:\n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\n\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\n\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\n        df = self.query_run(query)\n        return df\n\n    def legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n\n        SQL Equivalent:\n\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\n        query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\n        if timeframe is True:\n            query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \n        df = self.query_run(query)\n        return df\n\n    def link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n        Returns the number of clients with at least one linkage\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from \n                (select participant_id from stints.classify_by_program) x \n            join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n        '''\n        query = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\n        if hub_initiated is False and timeframe is False:\n            df = self.query_run(query)\n            return df\n        if started_linked.lower() == \"both\":\n            if hub_initiated is False:\n                query = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\n            if hub_initiated is True:\n                query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\n        if hub_initiated is True and timeframe is False:\n            query = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\n        else:\n            if hub_initiated is False and timeframe is True:\n                query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n            if hub_initiated is True and timeframe is True:\n                query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\n        df = self.query_run(query)\n        return df\n\n    def link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\n        if cutoff_date == \"t1\":\n            cutoff_date = self.t1\n        if link_type.lower() == \"education\":\n            inequality_sign = '&lt;'\n        if link_type.lower() == \"employment\":\n            inequality_sign = '&gt;'\n        link_type = f\"'{link_type}'\"\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        query = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\n        if hub_initiated == True:\n            query = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\n        if first_n_months is not None:\n            query = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\n        df = self.query_run(query)\n        return df\n\n    def link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n        SQL Equivalent:\n\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\n\n        query = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\n        if timeframe == True:\n            if started_linked == \"linked_date\" or started_linked == \"start_date\":\n                query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n            if started_linked == \"both\" or started_linked == \"Both\":\n                query = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\n            if hub_initiated == True:\n                query = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\n        if timeframe == False and hub_initiated == True:\n            query = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\n        df = self.query_run(query)\n        return df\n\n    def programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n\n\n        SQL Equivalent:\n\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n\n        '''\n        query = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\n\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\n\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\n        df = self.query_run(query)\n        return df\n\n    def programs_grant_tally(self, start_end = None):\n'''\n        Tallies the number of grants in a timeframe\n\n        Parameters:\n            start_end: optional, to find the number of grants started or ended use \"start_date\" or \"end_date\"\n\n\n        SQL Equivalent:\n\n            select grant_type, count(distinct participant_id) from stints.classify_by_program group by grant_type;\n        '''\n        query = f'''select grant_type, count(distinct participant_id) from {self.table} group by grant_type'''\n        if start_end == \"start_date\":\n            query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or active_date between {self.q_t1} and {self.q_t2}''')\n        elif start_end == \"end_date\":\n            query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or closed_date between {self.q_t1} and {self.q_t2}''')\n        df = self.query_run(query)\n        return df\n\n    def programs_service_tally(self, service_column):\n'''\n        Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n\n        Parameters:\n            Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n\n\n        SQL Equivalent: \n\n            select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n        '''\n        if service_column.lower() == \"outreach\":\n            query = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\n        else:\n            query = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\n\n        df = self.query_run(query)\n        return df\n\n\n    def programs_had_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n        Counts clients who have at least one recorded session with a case manager or outreach worker\n\n        Parameters:\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n        SQL Equivalent: \n\n            select count(distinct participant_id) from stints.classify_by_program \n            join civicore.case_sessions using(participant_id) \n            where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\n        if cm_outreach.lower() == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach.lower() == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        query = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n        if timeframe is True:\n            query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n        df = self.query_run(query)\n        return df\n\n    def programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n        SQL Equivalent:\n\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\n        if cm_outreach.lower() == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach.lower() == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        query = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\n        df = self.query_run(query)\n        return df\n\n    def programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n\n        SQL Equivalent:\n\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\n        if demographic == \"age\" and self.joined_participants == False:\n            query = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\n        else:\n            query = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\n        print(self.table)\n        if self.joined_participants == False and demographic != \"age\":\n            query = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\n        df = self.query_run(query)\n        if percentages == True:\n            df = self.percentage_convert(df)\n        return df\n\n    def programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n        Finds the length of case management or outreach sessions\n\n        Parameters:\n            cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n            grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n\n        SQL Equivalent:\n\n            select \n                avg(hours) * 60 as overall,\n                avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\n        if cm_outreach == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        if grouped is False:\n            query = f'''select \n            avg(hours) * 60 as overall,\n         avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n            if timeframe is True:\n                query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n        if grouped is True:\n            if timeframe is True:  \n                query = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\n\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\n            else: \n                query = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_casenote = {cm_outreach})\n\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\n        df = self.query_run(query)\n        return df\n\n    def programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n\n        SQL Equivalent:\n\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\n        query = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_case_outcomes","title":"<code>legal_case_outcomes(timeframe=True)</code>","text":"<p>returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)</p> <p>Parameters:</p> Name Type Description Default <code>timeframe</code> <code>Bool</code> <p>if true, only looks at cases between T1 and T2. Defaults to True</p> <code>True</code> <p>SQL Equivalent:</p> <pre><code>with ranked_df as \n(select * from \n    (SELECT participant_id, case_outcome, \n    GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n        (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n    group by participant_id, case_outcome) d1\nleft join tasks.highest_case using(case_outcome)),\nplea_concat as \n    (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n    else case_outcome end as case_outcome\nfrom (select case_outcome, sentence from ranked_df d1\nLEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\nWHERE d2.ranking IS NULL)h)\nselect case_outcome, count(case_outcome) from plea_concat\ngroup by case_outcome\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def legal_case_outcomes(self,  timeframe = True):\n'''\n    returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n\n    Parameters:\n        timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n    SQL Equivalent:\n\n        with ranked_df as \n        (select * from \n            (SELECT participant_id, case_outcome, \n            GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n            GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n            group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)),\n        plea_concat as \n            (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n            else case_outcome end as case_outcome\n        from (select case_outcome, sentence from ranked_df d1\n        LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n        WHERE d2.ranking IS NULL)h)\n        select case_outcome, count(case_outcome) from plea_concat\n        group by case_outcome\n    '''\n    if timeframe is True: \n        query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1\nleft join tasks.highest_case using(case_outcome)), \nplea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\nfrom (select case_outcome, sentence from ranked_df d1\nLEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\nWHERE\n    d2.ranking IS NULL)h)\nselect case_outcome, count(case_outcome) from plea_concat\ngroup by case_outcome\n    '''\n    else: \n        query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id)) r\ngroup by participant_id, case_outcome) d1\nleft join tasks.highest_case using(case_outcome)), \nplea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\nfrom (select case_outcome, sentence from ranked_df d1\nLEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\nWHERE\n    d2.ranking IS NULL)h)\nselect case_outcome, count(case_outcome) from plea_concat\ngroup by case_outcome'''\n    df = self.query_run(query)\n    return df  \n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_case_statuses","title":"<code>legal_case_statuses(timeframe=False, opened_closed='closed')</code>","text":"<p>returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2</p> <p>Parameters:</p> Name Type Description Default <code>timeframe(Bool)</code> <p>if true, only looks at cases between T1 and T2. Defaults to False</p> required <code>opened_closed</code> <p>only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened</p> <code>'closed'</code> <p>SQL Equivalent:</p> <pre><code>with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\n    COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n    COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL\nselect case_outcome,\n    COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n    COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n\n\n        SQL Equivalent:\n\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n\n        '''\n\n        if timeframe is False:\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                relevant_date = \"arrest_date\"\n            else:\n                relevant_date = \"case_outcome_date\"\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Found Guilty' then 4\nelse 5\nend asc'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_case_type","title":"<code>legal_case_type(timeframe=False, opened_closed='opened', percentage=False, case_client='case')</code>","text":"<p>Returns counts of cases by type (gun, drug, etc) </p> <p>Parameters:</p> Name Type Description Default <code>timeframe</code> <code>Bool</code> <p>if true, only looks at cases between T1 and T2. Defaults to False</p> <code>False</code> <code>opened_closed</code> <p>only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened</p> <code>'opened'</code> <code>percentage</code> <code>Bool</code> <p>if True, returns a percentage breakdown. Defaults to False</p> <code>False</code> <code>case_client</code> <p>\"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"</p> <code>'case'</code> <p>SQL Equivalent:</p> <pre><code>WITH mleg AS (\n    SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM participants.hd\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.*\n    FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def legal_case_type(self, timeframe = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n\n\n        SQL Equivalent:\n\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\n        if case_client == \"case\":\n            case_client = \"case_id\"\n        if case_client ==\"client\":\n            case_client = \"participant_id\"     \n        query = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                opened_closed = \"arrest_date\"\n                query = self.query_modify(str(query), f'''and (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\n            else:\n                opened_closed = \"case_outcome_date\"\n                query = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \n        df = self.query_run(query)\n        if percentage is True:\n            df = self.percentage_convert(df, replace= False)\n        return df   \n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_fel_reduction","title":"<code>legal_fel_reduction(timeframe=True)</code>","text":"<p>Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table</p> <p>Parameters:</p> Name Type Description Default <code>timeframe(Bool)</code> <p>if true, only looks at cases between T1 and T2. Defaults to True</p> required <p>SQL Equivalent:</p> <pre><code>select felony, count(felony) FROM \n    (select CASE \n        WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n        ELSE 'remained' \n    END AS felony from\n        (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                CASE\n                    WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                    ELSE 'Not Lower'\n                END AS rank_comparison from civicore.legal lt \n                join stints.classify_by_program using(participant_id) \n                JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n            GROUP BY participant_id) j\n        ) k \n    group by felony;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def legal_fel_reduction(self, timeframe = True):\n'''\n    Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n\n    Parameters:\n        timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n    SQL Equivalent:\n\n        select felony, count(felony) FROM \n            (select CASE \n                WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                ELSE 'remained' \n            END AS felony from\n                (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                    FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                        CASE\n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                            ELSE 'Not Lower'\n                        END AS rank_comparison from civicore.legal lt \n                        join stints.classify_by_program using(participant_id) \n                        JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                        JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                        where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                    GROUP BY participant_id) j\n                ) k \n            group by felony;\n    '''\n    if timeframe is True: \n        query = f'''select felony, count(felony) FROM \n(select CASE \n                WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n        ELSE 'remained' END AS felony  \n        from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n        CASE         \n                        WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                        ELSE 'Not Lower'     \n            END AS rank_comparison from civicore.legal lt \n                join {self.table} using(participant_id) \n        JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n        JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n        where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n        GROUP BY participant_id) j) k group by felony;'''\n    else:\n        query = f'''select felony, count(felony) FROM \n(select CASE \n                WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n        ELSE 'remained' END AS felony  \n        from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n        CASE         \n                        WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                        ELSE 'Not Lower'     \n            END AS rank_comparison from civicore.legal lt \n                join {self.table} using(participant_id) \n        JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n        JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n        where class_after_plea_trial IS NOT NULL) h \n        GROUP BY participant_id) j) k group by felony;'''\n    df = self.query_run(query)\n    return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_in_custody","title":"<code>legal_in_custody(age=19, cutoff_date='active_date', tally=True)</code>","text":"<p>Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)</p> <p>Parameters:</p> Name Type Description Default <code>age</code> <p>the cutoff age of clients to search for, defaults to 19</p> <code>19</code> <code>cutoff</code> <code>date</code> <p>the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"</p> required <code>tally(Bool)</code> <p>True returns a count of clients, False offers a table. defaults to True</p> required <p>SQL Equivalent:</p> <pre><code>with custody_ids as \n(select distinct participant_id from \n    (select distinct participant_id from stints.classify_by_program\n    join civicore.participants using(participant_ID)\n    where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\njoin civicore.trunc_legal tl using(participant_id)\n)\nselect custody_status, count(distinct participant_id) from \n(select x.participant_id, x.recent_date, \n    group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n    group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n    group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n    group_concat(distinct comments SEPARATOR ', ') comments \nfrom \n    (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\ngroup by participant_id) y\ngroup by custody_status;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n\n\n        SQL Equivalent:\n\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\n        if cutoff_date.lower() == \"t1\":\n            cutoff_date = self.t1\n        if cutoff_date.lower()  == \"t2\":\n            cutoff_date = self.t2\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        if tally is True: \n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\n        else:\n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_in_custody_links","title":"<code>legal_in_custody_links()</code>","text":"<p>Returns the number of people in custody with linkages</p> <p>SQL Equivalent:</p> <pre><code>with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id);\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n\n\n        SQL Equivalent:\n\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\n        query = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_lclc_involvement","title":"<code>legal_lclc_involvement()</code>","text":"<p>returns linkage and case session tallies for clients with cases ended in a timeframe</p> <p>SQL Equivalent:</p> <pre><code>with outcomes as (select participant_id, charge, case_type,\n    case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n    (select * from \n        (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n        GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n        GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n    group by participant_id, case_outcome) d1\nleft join tasks.highest_case using(case_outcome)) d),\nlinks as (select participant_id,\n    count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n    count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\nsessions as (select participant_id,\n    COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\nfrom stints.classify_by_program\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\ngroup by participant_id)\nselect o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\nleft join links l on o.participant_id = l.participant_id\nleft join sessions s on o.participant_id = s.participant_id;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def legal_lclc_involvement(self):\n'''\n        returns linkage and case session tallies for clients with cases ended in a timeframe\n\n\n        SQL Equivalent:\n\n            with outcomes as (select participant_id, charge, case_type,\n                case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n                (select * from \n                    (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                    GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)) d),\n            links as (select participant_id,\n                count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n                count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n                from civicore.linkages\n                where hub_initiated = \"yes\"\n                group by participant_id),\n            sessions as (select participant_id,\n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n            group by participant_id)\n            select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n            left join links l on o.participant_id = l.participant_id\n            left join sessions s on o.participant_id = s.participant_id;\n        '''\n        query = f'''with outcomes as (select participant_id, charge, case_type,\n    case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)) d),\nlinks as (select participant_id,\ncount(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\ncount(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\nfrom civicore.linkages\nwhere hub_initiated = \"yes\"\ngroup by participant_id),\nsessions as (select participant_id,\n        COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\ngroup by participant_id)\n\nselect o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\nleft join links l on o.participant_id = l.participant_id\nleft join sessions s on o.participant_id = s.participant_id'''\n        df = self.query_run(query)\n        df = df.fillna(0)\n        df['order'] = df.groupby('participant_id').cumcount() + 1\n        pivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\n        pivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\n        max_cases = df['order'].max()\n\n        case_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\n        case_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\n        other_columns = [col for col in pivoted_df.columns if col not in case_columns]\n        pivoted_df = pivoted_df[case_columns + other_columns]\n        pivoted_df = pivoted_df.reset_index()\n        if self.clipboard is True:\n            pivoted_df.to_clipboard()\n        return pivoted_df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_one_case","title":"<code>legal_one_case(timeframe=True)</code>","text":"<p>Returns counts of case outcomes for clients with one case</p> <p>Parameters:</p> Name Type Description Default <code>timeframe(Bool)</code> <p>if true, only looks at cases between T1 and T2. Defaults to True</p> required <p>SQL Equivalent:</p> <pre><code>with one_cases as (select * from \n    (select participant_id from \n        (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n        join civicore.legal l using(participant_id)\n        where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n        group by participant_id) d\n    where case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \n        if timeframe is True:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        else:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_pending_cases","title":"<code>legal_pending_cases(t1_t2='t1', also_ended=False)</code>","text":"<p>Counts the number of people with pending cases at a given point</p> <p>Parameters:</p> Name Type Description Default <code>t1_t2</code> <p>the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end</p> <code>'t1'</code> <code>also_ended(Bool)</code> <p>True only counts clients who also had a case end. Defaults to False  </p> required <p>SQL Equivalent:</p> <pre><code>select count(distinct participant_id) from stints.classify_by_program\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\n        if t1_t2 == \"t1\": \n            t1_t2 = self.q_t1\n        else:\n            t1_t2 = self.q_t2\n        if also_ended == False:\n            query = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\n            df = self.query_run(query)\n            return df\n        else:\n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\n\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\n\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_rearrested","title":"<code>legal_rearrested(timeframe=True)</code>","text":"<p>Returns a count of clients rearrested</p> <p>Parameters:</p> Name Type Description Default <code>timeframe</code> <code>Bool</code> <p>True sums rearrests in the timeframe, False does not. Defaults to True</p> <code>True</code> <p>SQL Equivalent:</p> <pre><code>WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM stints.classify_by_program) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \non m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n\n        SQL Equivalent:\n\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\n        query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\n        if timeframe is True:\n            query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.legal_tally","title":"<code>legal_tally(pending=False)</code>","text":"<p>Tallies clients with a case in CiviCore</p> <p>Parameters:</p> Name Type Description Default <code>pending</code> <code>Bool</code> <p>if True, tallies the clients with a case pending. Defaults to False. </p> <code>False</code> <p>SQL Equivalent:</p> <pre><code>with mlegal as \n    (select * from \n        (select participant_id, active_date, closed_date from stints.classify_by_program)k\n    join civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; '2023-08-31';\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n\n\n        SQL Equivalent:\n\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\n        query = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\n        if pending is True:\n            query = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#linkages","title":"Linkages","text":"<p>             Bases: <code>Tables</code></p> <p>Sets up a table for a given timeframe Parameters:</p> <pre><code>t1: start date, formatted as \"YYYY-MM-DD\"\nt2: end date, formatted as \"YYYY-MM-DD\"\nprint_sql (Bool): whether to print the SQL statements when run, defaults to True\nclipboard (Bool): whether to copy the output table to your clipboard, defaults to False\ndefault_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>class Queries(Tables):\n'''\n    Sets up a table for a given timeframe\n    Parameters:\n\n        t1: start date, formatted as \"YYYY-MM-DD\"\n        t2: end date, formatted as \"YYYY-MM-DD\"\n        print_sql (Bool): whether to print the SQL statements when run, defaults to True\n        clipboard (Bool): whether to copy the output table to your clipboard, defaults to False\n        default_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n    '''\n    def dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n        Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n\n        Parameters:\n\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n            age: threshold at which a client is counted as a juvenile, defaults to 18\n            cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n\n\n        SQL Equivalent:\n\n            select \n                count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n            from stints.classify_by_program\n            join civicore.participants using(participant_id);'''\n        if cutoff_date.lower() == \"t1\":\n            cutoff_date = self.t1\n        if cutoff_date.lower()  == \"t2\":\n            cutoff_date = self.t2\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        if tally is True:\n            query = f'''select \n                count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n                from {self.table}\n                join civicore.participants using(participant_id)'''\n        else: \n            query = f'''select \n                l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n                from {self.table} l\n                join civicore.participants using(participant_id)'''\n        modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n        if new_clients is True:\n            query = self.query_modify(str(query), modifier)\n        df = self.query_run(query)\n        return(df)\n\n    def dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n        Returns a count of client races or genders\n\n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            race_gender: the category to tally, enter either \"race\" or \"gender\"\n\n\n        SQL Equivalent:\n\n            select race, count(distinct participant_id)\n            from stints.classify_by_program\n            join civicore.participants using(participant_id)\n            group by race;\n        '''\n        query = f'''select {race_gender}, count(distinct participant_id)\n        from {self.table}\n        join civicore.participants using(participant_id)\n        group by {race_gender}'''\n        modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n        if new_clients is True:\n            query = self.query_modify(str(query), modifier)  # Use self.query_modify here\n        df = self.query_run(query)\n        return(df)\n\n    def dem_recent_address(self):\n'''\n        Finds the recent addresses of clients\n\n\n        SQL Equivalent:\n\n            with ranked_addresses as\n                (select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id \n                    ORDER BY primary_address DESC, entered_date DESC) AS rn \n                from stints.classify_by_program\n                join civicore.address a using(participant_id))\n\n                select * from ranked_addresses\n                where rn = 1\n                    ;\n        '''\n        query = f'''with ranked_addresses as(select first_name, last_name, a.*,\n                ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n                join civicore.address a using(participant_id))\n                select * from ranked_addresses\n                where rn = 1\n                '''\n        df = self.query_run(query)\n        return(df)\n\n    def docs_has_formatted(self):\n'''\n        checks if clients have ISPs or Assessments and if they are formatted correctly\n        '''\n        query = f'''SELECT DISTINCT (participant_id), ASSM_ISP_formatted, has_ASSM_ISP, FCS_formatted, has_FCS,  BP_formatted, has_BP, PCL_formatted, has_PCL,  has_cdc, assess\nFROM (select * from {self.table}) cr\nLEFT JOIN( select participant_id, first_name, last_name\nfrom civicore.participants) p USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_ASSM_ISP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS ASSM_ISP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_ASSM_ISP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*'\nGROUP BY participant_id, Has_ASSM_ISP\n) assm USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_FCS_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS FCS_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*FCS.*|.*Crime.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_FCS\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*FCS.*|.*Crime.*'\nGROUP BY participant_id, has_FCS\n) fcs USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_BP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS BP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*BP.*|.*Buss.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_BP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*BP.*|.*Buss.*'\nGROUP BY participant_id, has_BP\n) bp USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_PCL_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS PCL_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_PCL\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*'\nGROUP BY participant_id, has_PCL\n) PCL USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_CDC_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS CDC_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_CDC\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*'\nGROUP BY participant_id, has_CDC\n) cdc USING (participant_id)\nleft join(\nselect participant_id,\n        COUNT(CASE\n                WHEN d.document_type = 'Assessments' THEN 1 ELSE NULL END) as assess\n from documents.unfiltered d\n group by participant_id) asseses USING (participant_id);'''\n        df = self.query_run(query)\n        return df\n\n\n    def legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n\n\n        SQL Equivalent:\n\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\n        query = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\n        if pending is True:\n            query = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\n        df = self.query_run(query)\n        return df\n\n    def legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n\n\n        SQL Equivalent:\n\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\n        if cutoff_date.lower() == \"t1\":\n            cutoff_date = self.t1\n        if cutoff_date.lower()  == \"t2\":\n            cutoff_date = self.t2\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        if tally is True: \n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\n        else:\n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\n        df = self.query_run(query)\n        return df\n\n    def legal_lclc_involvement(self):\n'''\n        returns linkage and case session tallies for clients with cases ended in a timeframe\n\n\n        SQL Equivalent:\n\n            with outcomes as (select participant_id, charge, case_type,\n                case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n                (select * from \n                    (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                    GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)) d),\n            links as (select participant_id,\n                count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n                count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n                from civicore.linkages\n                where hub_initiated = \"yes\"\n                group by participant_id),\n            sessions as (select participant_id,\n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n            group by participant_id)\n            select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n            left join links l on o.participant_id = l.participant_id\n            left join sessions s on o.participant_id = s.participant_id;\n        '''\n        query = f'''with outcomes as (select participant_id, charge, case_type,\n    case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)) d),\nlinks as (select participant_id,\ncount(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\ncount(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\nfrom civicore.linkages\nwhere hub_initiated = \"yes\"\ngroup by participant_id),\nsessions as (select participant_id,\n        COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\ngroup by participant_id)\n\nselect o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\nleft join links l on o.participant_id = l.participant_id\nleft join sessions s on o.participant_id = s.participant_id'''\n        df = self.query_run(query)\n        df = df.fillna(0)\n        df['order'] = df.groupby('participant_id').cumcount() + 1\n        pivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\n        pivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\n        max_cases = df['order'].max()\n\n        case_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\n        case_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\n        other_columns = [col for col in pivoted_df.columns if col not in case_columns]\n        pivoted_df = pivoted_df[case_columns + other_columns]\n        pivoted_df = pivoted_df.reset_index()\n        if self.clipboard is True:\n            pivoted_df.to_clipboard()\n        return pivoted_df\n\n    def legal_fel_reduction(self, timeframe = True):\n'''\n        Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            select felony, count(felony) FROM \n                (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                    ELSE 'remained' \n                END AS felony from\n                    (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                            CASE\n                                WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                                ELSE 'Not Lower'\n                            END AS rank_comparison from civicore.legal lt \n                            join stints.classify_by_program using(participant_id) \n                            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                        GROUP BY participant_id) j\n                    ) k \n                group by felony;\n        '''\n        if timeframe is True: \n            query = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n            GROUP BY participant_id) j) k group by felony;'''\n        else:\n            query = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL) h \n            GROUP BY participant_id) j) k group by felony;'''\n        df = self.query_run(query)\n        return df\n\n    def legal_case_outcomes(self,  timeframe = True):\n'''\n        returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            with ranked_df as \n            (select * from \n                (SELECT participant_id, case_outcome, \n                GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n                GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                    (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)),\n            plea_concat as \n                (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n                else case_outcome end as case_outcome\n            from (select case_outcome, sentence from ranked_df d1\n            LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n            WHERE d2.ranking IS NULL)h)\n            select case_outcome, count(case_outcome) from plea_concat\n            group by case_outcome\n        '''\n        if timeframe is True: \n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome\n        '''\n        else: \n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id)) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome'''\n        df = self.query_run(query)\n        return df  \n\n    def legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n\n\n        SQL Equivalent:\n\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n\n        '''\n\n        if timeframe is False:\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                relevant_date = \"arrest_date\"\n            else:\n                relevant_date = \"case_outcome_date\"\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Found Guilty' then 4\nelse 5\nend asc'''\n        df = self.query_run(query)\n        return df\n\n    def legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \n        if timeframe is True:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        else:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        df = self.query_run(query)\n        return df\n\n    def legal_case_type(self, timeframe = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n\n\n        SQL Equivalent:\n\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\n        if case_client == \"case\":\n            case_client = \"case_id\"\n        if case_client ==\"client\":\n            case_client = \"participant_id\"     \n        query = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                opened_closed = \"arrest_date\"\n                query = self.query_modify(str(query), f'''and (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\n            else:\n                opened_closed = \"case_outcome_date\"\n                query = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \n        df = self.query_run(query)\n        if percentage is True:\n            df = self.percentage_convert(df, replace= False)\n        return df   \n\n    def legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n\n\n        SQL Equivalent:\n\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\n        query = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\n        df = self.query_run(query)\n        return df\n\n\n    def legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\n        if t1_t2 == \"t1\": \n            t1_t2 = self.q_t1\n        else:\n            t1_t2 = self.q_t2\n        if also_ended == False:\n            query = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\n            df = self.query_run(query)\n            return df\n        else:\n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\n\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\n\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\n        df = self.query_run(query)\n        return df\n\n    def legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n\n        SQL Equivalent:\n\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\n        query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\n        if timeframe is True:\n            query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \n        df = self.query_run(query)\n        return df\n\n    def link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n        Returns the number of clients with at least one linkage\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from \n                (select participant_id from stints.classify_by_program) x \n            join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n        '''\n        query = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\n        if hub_initiated is False and timeframe is False:\n            df = self.query_run(query)\n            return df\n        if started_linked.lower() == \"both\":\n            if hub_initiated is False:\n                query = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\n            if hub_initiated is True:\n                query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\n        if hub_initiated is True and timeframe is False:\n            query = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\n        else:\n            if hub_initiated is False and timeframe is True:\n                query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n            if hub_initiated is True and timeframe is True:\n                query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\n        df = self.query_run(query)\n        return df\n\n    def link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\n        if cutoff_date == \"t1\":\n            cutoff_date = self.t1\n        if link_type.lower() == \"education\":\n            inequality_sign = '&lt;'\n        if link_type.lower() == \"employment\":\n            inequality_sign = '&gt;'\n        link_type = f\"'{link_type}'\"\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        query = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\n        if hub_initiated == True:\n            query = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\n        if first_n_months is not None:\n            query = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\n        df = self.query_run(query)\n        return df\n\n    def link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n        SQL Equivalent:\n\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\n\n        query = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\n        if timeframe == True:\n            if started_linked == \"linked_date\" or started_linked == \"start_date\":\n                query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n            if started_linked == \"both\" or started_linked == \"Both\":\n                query = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\n            if hub_initiated == True:\n                query = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\n        if timeframe == False and hub_initiated == True:\n            query = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\n        df = self.query_run(query)\n        return df\n\n    def programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n\n\n        SQL Equivalent:\n\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n\n        '''\n        query = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\n\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\n\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\n        df = self.query_run(query)\n        return df\n\n    def programs_grant_tally(self, start_end = None):\n'''\n        Tallies the number of grants in a timeframe\n\n        Parameters:\n            start_end: optional, to find the number of grants started or ended use \"start_date\" or \"end_date\"\n\n\n        SQL Equivalent:\n\n            select grant_type, count(distinct participant_id) from stints.classify_by_program group by grant_type;\n        '''\n        query = f'''select grant_type, count(distinct participant_id) from {self.table} group by grant_type'''\n        if start_end == \"start_date\":\n            query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or active_date between {self.q_t1} and {self.q_t2}''')\n        elif start_end == \"end_date\":\n            query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or closed_date between {self.q_t1} and {self.q_t2}''')\n        df = self.query_run(query)\n        return df\n\n    def programs_service_tally(self, service_column):\n'''\n        Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n\n        Parameters:\n            Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n\n\n        SQL Equivalent: \n\n            select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n        '''\n        if service_column.lower() == \"outreach\":\n            query = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\n        else:\n            query = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\n\n        df = self.query_run(query)\n        return df\n\n\n    def programs_had_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n        Counts clients who have at least one recorded session with a case manager or outreach worker\n\n        Parameters:\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n        SQL Equivalent: \n\n            select count(distinct participant_id) from stints.classify_by_program \n            join civicore.case_sessions using(participant_id) \n            where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\n        if cm_outreach.lower() == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach.lower() == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        query = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n        if timeframe is True:\n            query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n        df = self.query_run(query)\n        return df\n\n    def programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n        SQL Equivalent:\n\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\n        if cm_outreach.lower() == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach.lower() == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        query = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\n        df = self.query_run(query)\n        return df\n\n    def programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n\n        SQL Equivalent:\n\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\n        if demographic == \"age\" and self.joined_participants == False:\n            query = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\n        else:\n            query = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\n        print(self.table)\n        if self.joined_participants == False and demographic != \"age\":\n            query = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\n        df = self.query_run(query)\n        if percentages == True:\n            df = self.percentage_convert(df)\n        return df\n\n    def programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n        Finds the length of case management or outreach sessions\n\n        Parameters:\n            cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n            grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n\n        SQL Equivalent:\n\n            select \n                avg(hours) * 60 as overall,\n                avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\n        if cm_outreach == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        if grouped is False:\n            query = f'''select \n            avg(hours) * 60 as overall,\n         avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n            if timeframe is True:\n                query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n        if grouped is True:\n            if timeframe is True:  \n                query = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\n\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\n            else: \n                query = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_casenote = {cm_outreach})\n\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\n        df = self.query_run(query)\n        return df\n\n    def programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n\n        SQL Equivalent:\n\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\n        query = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.link_edu_job","title":"<code>link_edu_job(hub_initiated=True, link_type='education', age=19, cutoff_date='t1', first_n_months=None)</code>","text":"<p>Counts either meployment or education linkages among clients</p> <p>Parameters:</p> Name Type Description Default <code>hub_initiated</code> <code>Bool</code> <p>whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True</p> <code>True</code> <code>link_type</code> <p>\"education\" returns education linkages, while \"employment\" returns employment linkages</p> <code>'education'</code> <code>age</code> <p>the age cutoff for clients, defaults to 19</p> <code>19</code> <code>cutoff</code> <code>date</code> <p>the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"</p> required <code>first_n_months(integer)</code> <p>optional, only counts linkages made in the first N months of a client's stint</p> required <p>SQL Equivalent:</p> <pre><code>select count(distinct participant_id) from civicore.linkages l\njoin \n    (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n    join civicore.participants using(participant_ID)\n    where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\n        if cutoff_date == \"t1\":\n            cutoff_date = self.t1\n        if link_type.lower() == \"education\":\n            inequality_sign = '&lt;'\n        if link_type.lower() == \"employment\":\n            inequality_sign = '&gt;'\n        link_type = f\"'{link_type}'\"\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        query = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\n        if hub_initiated == True:\n            query = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\n        if first_n_months is not None:\n            query = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.link_goal_area","title":"<code>link_goal_area(hub_initiated=True, timeframe=True, started_linked='linked_date')</code>","text":"<p>Returns counts of linkages by goal area (service).</p> <p>Parameters:</p> Name Type Description Default <code>hub_initiated</code> <code>Bool</code> <p>whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True</p> <code>True</code> <code>timeframe</code> <code>Bool</code> <p>whether to only count linkages made between T1 and T2, defaults to True</p> <code>True</code> <code>started_linked</code> <p>only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"</p> <code>'linked_date'</code> <p>SQL Equivalent:</p> <pre><code>with separated_goals as \n    (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n    SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n        (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n        join civicore.linkages l using(participant_id)) s\n    JOIN (\n        SELECT 1 AS n UNION ALL\n        SELECT 2 UNION ALL\n        SELECT 3 UNION ALL\n        SELECT 4 UNION ALL\n        SELECT 5 UNION ALL\n        SELECT 6 UNION ALL\n        SELECT 7 UNION ALL\n        SELECT 8 UNION ALL\n        SELECT 9\n    ) AS numbers\n    ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\nwhere linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n        SQL Equivalent:\n\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\n\n        query = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\n        if timeframe == True:\n            if started_linked == \"linked_date\" or started_linked == \"start_date\":\n                query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n            if started_linked == \"both\" or started_linked == \"Both\":\n                query = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\n            if hub_initiated == True:\n                query = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\n        if timeframe == False and hub_initiated == True:\n            query = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.link_tally","title":"<code>link_tally(hub_initiated=True, timeframe=False, started_linked='linked_date')</code>","text":"<p>Returns the number of clients with at least one linkage</p> <p>Parameters:</p> Name Type Description Default <code>hub_initiated</code> <code>Bool</code> <p>whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True</p> <code>True</code> <code>timeframe</code> <code>Bool</code> <p>whether to only count people who had at least one linkage between T1 and T2, defaults to False</p> <code>False</code> <code>started_linked</code> <p>only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"</p> <code>'linked_date'</code> <p>SQL Equivalent:</p> <pre><code>select count(distinct participant_id) from \n    (select participant_id from stints.classify_by_program) x \njoin civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n    Returns the number of clients with at least one linkage\n\n    Parameters:\n        hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n        timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n        started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n    SQL Equivalent:\n\n        select count(distinct participant_id) from \n            (select participant_id from stints.classify_by_program) x \n        join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n    '''\n    query = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\n    if hub_initiated is False and timeframe is False:\n        df = self.query_run(query)\n        return df\n    if started_linked.lower() == \"both\":\n        if hub_initiated is False:\n            query = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\n        if hub_initiated is True:\n            query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\n    if hub_initiated is True and timeframe is False:\n        query = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\n    else:\n        if hub_initiated is False and timeframe is True:\n            query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n        if hub_initiated is True and timeframe is True:\n            query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\n    df = self.query_run(query)\n    return df\n</code></pre>"},{"location":"tables_ref/#programs","title":"Programs","text":"<p>             Bases: <code>Tables</code></p> <p>Sets up a table for a given timeframe Parameters:</p> <pre><code>t1: start date, formatted as \"YYYY-MM-DD\"\nt2: end date, formatted as \"YYYY-MM-DD\"\nprint_sql (Bool): whether to print the SQL statements when run, defaults to True\nclipboard (Bool): whether to copy the output table to your clipboard, defaults to False\ndefault_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>class Queries(Tables):\n'''\n    Sets up a table for a given timeframe\n    Parameters:\n\n        t1: start date, formatted as \"YYYY-MM-DD\"\n        t2: end date, formatted as \"YYYY-MM-DD\"\n        print_sql (Bool): whether to print the SQL statements when run, defaults to True\n        clipboard (Bool): whether to copy the output table to your clipboard, defaults to False\n        default_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n    '''\n    def dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n        Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n\n        Parameters:\n\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n            age: threshold at which a client is counted as a juvenile, defaults to 18\n            cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n\n\n        SQL Equivalent:\n\n            select \n                count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n            from stints.classify_by_program\n            join civicore.participants using(participant_id);'''\n        if cutoff_date.lower() == \"t1\":\n            cutoff_date = self.t1\n        if cutoff_date.lower()  == \"t2\":\n            cutoff_date = self.t2\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        if tally is True:\n            query = f'''select \n                count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n                from {self.table}\n                join civicore.participants using(participant_id)'''\n        else: \n            query = f'''select \n                l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n                from {self.table} l\n                join civicore.participants using(participant_id)'''\n        modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n        if new_clients is True:\n            query = self.query_modify(str(query), modifier)\n        df = self.query_run(query)\n        return(df)\n\n    def dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n        Returns a count of client races or genders\n\n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            race_gender: the category to tally, enter either \"race\" or \"gender\"\n\n\n        SQL Equivalent:\n\n            select race, count(distinct participant_id)\n            from stints.classify_by_program\n            join civicore.participants using(participant_id)\n            group by race;\n        '''\n        query = f'''select {race_gender}, count(distinct participant_id)\n        from {self.table}\n        join civicore.participants using(participant_id)\n        group by {race_gender}'''\n        modifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\n        if new_clients is True:\n            query = self.query_modify(str(query), modifier)  # Use self.query_modify here\n        df = self.query_run(query)\n        return(df)\n\n    def dem_recent_address(self):\n'''\n        Finds the recent addresses of clients\n\n\n        SQL Equivalent:\n\n            with ranked_addresses as\n                (select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id \n                    ORDER BY primary_address DESC, entered_date DESC) AS rn \n                from stints.classify_by_program\n                join civicore.address a using(participant_id))\n\n                select * from ranked_addresses\n                where rn = 1\n                    ;\n        '''\n        query = f'''with ranked_addresses as(select first_name, last_name, a.*,\n                ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n                join civicore.address a using(participant_id))\n                select * from ranked_addresses\n                where rn = 1\n                '''\n        df = self.query_run(query)\n        return(df)\n\n    def docs_has_formatted(self):\n'''\n        checks if clients have ISPs or Assessments and if they are formatted correctly\n        '''\n        query = f'''SELECT DISTINCT (participant_id), ASSM_ISP_formatted, has_ASSM_ISP, FCS_formatted, has_FCS,  BP_formatted, has_BP, PCL_formatted, has_PCL,  has_cdc, assess\nFROM (select * from {self.table}) cr\nLEFT JOIN( select participant_id, first_name, last_name\nfrom civicore.participants) p USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_ASSM_ISP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS ASSM_ISP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_ASSM_ISP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*'\nGROUP BY participant_id, Has_ASSM_ISP\n) assm USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_FCS_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS FCS_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*FCS.*|.*Crime.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_FCS\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*FCS.*|.*Crime.*'\nGROUP BY participant_id, has_FCS\n) fcs USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_BP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS BP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*BP.*|.*Buss.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_BP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*BP.*|.*Buss.*'\nGROUP BY participant_id, has_BP\n) bp USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_PCL_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS PCL_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_PCL\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*'\nGROUP BY participant_id, has_PCL\n) PCL USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_CDC_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS CDC_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_CDC\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*'\nGROUP BY participant_id, has_CDC\n) cdc USING (participant_id)\nleft join(\nselect participant_id,\n        COUNT(CASE\n                WHEN d.document_type = 'Assessments' THEN 1 ELSE NULL END) as assess\n from documents.unfiltered d\n group by participant_id) asseses USING (participant_id);'''\n        df = self.query_run(query)\n        return df\n\n\n    def legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n\n\n        SQL Equivalent:\n\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\n        query = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\n        if pending is True:\n            query = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\n        df = self.query_run(query)\n        return df\n\n    def legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n\n\n        SQL Equivalent:\n\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\n        if cutoff_date.lower() == \"t1\":\n            cutoff_date = self.t1\n        if cutoff_date.lower()  == \"t2\":\n            cutoff_date = self.t2\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        if tally is True: \n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\n        else:\n            query = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\n        df = self.query_run(query)\n        return df\n\n    def legal_lclc_involvement(self):\n'''\n        returns linkage and case session tallies for clients with cases ended in a timeframe\n\n\n        SQL Equivalent:\n\n            with outcomes as (select participant_id, charge, case_type,\n                case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n                (select * from \n                    (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                    GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)) d),\n            links as (select participant_id,\n                count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n                count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n                from civicore.linkages\n                where hub_initiated = \"yes\"\n                group by participant_id),\n            sessions as (select participant_id,\n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n            group by participant_id)\n            select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n            left join links l on o.participant_id = l.participant_id\n            left join sessions s on o.participant_id = s.participant_id;\n        '''\n        query = f'''with outcomes as (select participant_id, charge, case_type,\n    case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)) d),\nlinks as (select participant_id,\ncount(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\ncount(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\nfrom civicore.linkages\nwhere hub_initiated = \"yes\"\ngroup by participant_id),\nsessions as (select participant_id,\n        COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\ngroup by participant_id)\n\nselect o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\nleft join links l on o.participant_id = l.participant_id\nleft join sessions s on o.participant_id = s.participant_id'''\n        df = self.query_run(query)\n        df = df.fillna(0)\n        df['order'] = df.groupby('participant_id').cumcount() + 1\n        pivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\n        pivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\n        max_cases = df['order'].max()\n\n        case_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\n        case_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\n        other_columns = [col for col in pivoted_df.columns if col not in case_columns]\n        pivoted_df = pivoted_df[case_columns + other_columns]\n        pivoted_df = pivoted_df.reset_index()\n        if self.clipboard is True:\n            pivoted_df.to_clipboard()\n        return pivoted_df\n\n    def legal_fel_reduction(self, timeframe = True):\n'''\n        Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            select felony, count(felony) FROM \n                (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                    ELSE 'remained' \n                END AS felony from\n                    (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                            CASE\n                                WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                                ELSE 'Not Lower'\n                            END AS rank_comparison from civicore.legal lt \n                            join stints.classify_by_program using(participant_id) \n                            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                        GROUP BY participant_id) j\n                    ) k \n                group by felony;\n        '''\n        if timeframe is True: \n            query = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n            GROUP BY participant_id) j) k group by felony;'''\n        else:\n            query = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL) h \n            GROUP BY participant_id) j) k group by felony;'''\n        df = self.query_run(query)\n        return df\n\n    def legal_case_outcomes(self,  timeframe = True):\n'''\n        returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            with ranked_df as \n            (select * from \n                (SELECT participant_id, case_outcome, \n                GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n                GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                    (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)),\n            plea_concat as \n                (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n                else case_outcome end as case_outcome\n            from (select case_outcome, sentence from ranked_df d1\n            LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n            WHERE d2.ranking IS NULL)h)\n            select case_outcome, count(case_outcome) from plea_concat\n            group by case_outcome\n        '''\n        if timeframe is True: \n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome\n        '''\n        else: \n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id)) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome'''\n        df = self.query_run(query)\n        return df  \n\n    def legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n\n\n        SQL Equivalent:\n\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n\n        '''\n\n        if timeframe is False:\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                relevant_date = \"arrest_date\"\n            else:\n                relevant_date = \"case_outcome_date\"\n            query = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Found Guilty' then 4\nelse 5\nend asc'''\n        df = self.query_run(query)\n        return df\n\n    def legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n\n\n        SQL Equivalent:\n\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \n        if timeframe is True:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        else:\n            query = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\n\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\n        df = self.query_run(query)\n        return df\n\n    def legal_case_type(self, timeframe = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n\n\n        SQL Equivalent:\n\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\n        if case_client == \"case\":\n            case_client = \"case_id\"\n        if case_client ==\"client\":\n            case_client = \"participant_id\"     \n        query = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\n        if timeframe is True:\n            if opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\n                opened_closed = \"arrest_date\"\n                query = self.query_modify(str(query), f'''and (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\n            else:\n                opened_closed = \"case_outcome_date\"\n                query = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \n        df = self.query_run(query)\n        if percentage is True:\n            df = self.percentage_convert(df, replace= False)\n        return df   \n\n    def legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n\n\n        SQL Equivalent:\n\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\n        query = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\n        df = self.query_run(query)\n        return df\n\n\n    def legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\n        if t1_t2 == \"t1\": \n            t1_t2 = self.q_t1\n        else:\n            t1_t2 = self.q_t2\n        if also_ended == False:\n            query = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\n            df = self.query_run(query)\n            return df\n        else:\n            query = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\n\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\n\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\n        df = self.query_run(query)\n        return df\n\n    def legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n\n        SQL Equivalent:\n\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\n        query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\n        if timeframe is True:\n            query = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \n        df = self.query_run(query)\n        return df\n\n    def link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n        Returns the number of clients with at least one linkage\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from \n                (select participant_id from stints.classify_by_program) x \n            join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n        '''\n        query = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\n        if hub_initiated is False and timeframe is False:\n            df = self.query_run(query)\n            return df\n        if started_linked.lower() == \"both\":\n            if hub_initiated is False:\n                query = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\n            if hub_initiated is True:\n                query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\n        if hub_initiated is True and timeframe is False:\n            query = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\n        else:\n            if hub_initiated is False and timeframe is True:\n                query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n            if hub_initiated is True and timeframe is True:\n                query = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\n        df = self.query_run(query)\n        return df\n\n    def link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n\n\n        SQL Equivalent:\n\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\n        if cutoff_date == \"t1\":\n            cutoff_date = self.t1\n        if link_type.lower() == \"education\":\n            inequality_sign = '&lt;'\n        if link_type.lower() == \"employment\":\n            inequality_sign = '&gt;'\n        link_type = f\"'{link_type}'\"\n        if cutoff_date.lower() != \"active_date\":\n            cutoff_date = f'\"{cutoff_date}\"'\n        query = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\n        if hub_initiated == True:\n            query = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\n        if first_n_months is not None:\n            query = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\n        df = self.query_run(query)\n        return df\n\n    def link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n\n\n        SQL Equivalent:\n\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\n\n        query = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\n        if timeframe == True:\n            if started_linked == \"linked_date\" or started_linked == \"start_date\":\n                query = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\n            if started_linked == \"both\" or started_linked == \"Both\":\n                query = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\n            if hub_initiated == True:\n                query = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\n        if timeframe == False and hub_initiated == True:\n            query = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\n        df = self.query_run(query)\n        return df\n\n    def programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n\n\n        SQL Equivalent:\n\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n\n        '''\n        query = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\n\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\n\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\n        df = self.query_run(query)\n        return df\n\n    def programs_grant_tally(self, start_end = None):\n'''\n        Tallies the number of grants in a timeframe\n\n        Parameters:\n            start_end: optional, to find the number of grants started or ended use \"start_date\" or \"end_date\"\n\n\n        SQL Equivalent:\n\n            select grant_type, count(distinct participant_id) from stints.classify_by_program group by grant_type;\n        '''\n        query = f'''select grant_type, count(distinct participant_id) from {self.table} group by grant_type'''\n        if start_end == \"start_date\":\n            query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or active_date between {self.q_t1} and {self.q_t2}''')\n        elif start_end == \"end_date\":\n            query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or closed_date between {self.q_t1} and {self.q_t2}''')\n        df = self.query_run(query)\n        return df\n\n    def programs_service_tally(self, service_column):\n'''\n        Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n\n        Parameters:\n            Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n\n\n        SQL Equivalent: \n\n            select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n        '''\n        if service_column.lower() == \"outreach\":\n            query = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\n        else:\n            query = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\n\n        df = self.query_run(query)\n        return df\n\n\n    def programs_had_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n        Counts clients who have at least one recorded session with a case manager or outreach worker\n\n        Parameters:\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n        SQL Equivalent: \n\n            select count(distinct participant_id) from stints.classify_by_program \n            join civicore.case_sessions using(participant_id) \n            where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\n        if cm_outreach.lower() == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach.lower() == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        query = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n        if timeframe is True:\n            query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n        df = self.query_run(query)\n        return df\n\n    def programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n        SQL Equivalent:\n\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\n        if cm_outreach.lower() == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach.lower() == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        query = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\n        df = self.query_run(query)\n        return df\n\n    def programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n\n        SQL Equivalent:\n\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\n        if demographic == \"age\" and self.joined_participants == False:\n            query = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\n        else:\n            query = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\n        print(self.table)\n        if self.joined_participants == False and demographic != \"age\":\n            query = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\n        df = self.query_run(query)\n        if percentages == True:\n            df = self.percentage_convert(df)\n        return df\n\n    def programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n        Finds the length of case management or outreach sessions\n\n        Parameters:\n            cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n            grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n\n        SQL Equivalent:\n\n            select \n                avg(hours) * 60 as overall,\n                avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\n        if cm_outreach == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        if grouped is False:\n            query = f'''select \n            avg(hours) * 60 as overall,\n         avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n            if timeframe is True:\n                query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n        if grouped is True:\n            if timeframe is True:  \n                query = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\n\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\n            else: \n                query = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_casenote = {cm_outreach})\n\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\n        df = self.query_run(query)\n        return df\n\n    def programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n\n        SQL Equivalent:\n\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\n        query = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.programs_by_demographic","title":"<code>programs_by_demographic(demographic=None, percentages=False)</code>","text":"<p>Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")</p> <p>Parameters:</p> Name Type Description Default <code>demographic</code> <p>the demographic of choice (\"age\", \"race\", \"gender\")</p> <code>None</code> <p>SQL Equivalent:</p> <pre><code>select gender, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from stints.classify_by_program\n    join civicore.participants using(participant_id) group by gender;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n\n        SQL Equivalent:\n\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\n        if demographic == \"age\" and self.joined_participants == False:\n            query = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\n        else:\n            query = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\n        print(self.table)\n        if self.joined_participants == False and demographic != \"age\":\n            query = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\n        df = self.query_run(query)\n        if percentages == True:\n            df = self.percentage_convert(df)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.programs_grant_tally","title":"<code>programs_grant_tally(start_end=None)</code>","text":"<p>Tallies the number of grants in a timeframe</p> <p>Parameters:</p> Name Type Description Default <code>start_end</code> <p>optional, to find the number of grants started or ended use \"start_date\" or \"end_date\"</p> <code>None</code> <p>SQL Equivalent:</p> <pre><code>select grant_type, count(distinct participant_id) from stints.classify_by_program group by grant_type;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def programs_grant_tally(self, start_end = None):\n'''\n    Tallies the number of grants in a timeframe\n\n    Parameters:\n        start_end: optional, to find the number of grants started or ended use \"start_date\" or \"end_date\"\n\n\n    SQL Equivalent:\n\n        select grant_type, count(distinct participant_id) from stints.classify_by_program group by grant_type;\n    '''\n    query = f'''select grant_type, count(distinct participant_id) from {self.table} group by grant_type'''\n    if start_end == \"start_date\":\n        query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or active_date between {self.q_t1} and {self.q_t2}''')\n    elif start_end == \"end_date\":\n        query = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or closed_date between {self.q_t1} and {self.q_t2}''')\n    df = self.query_run(query)\n    return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.programs_had_sessions","title":"<code>programs_had_sessions(timeframe=True, cm_outreach='cm')</code>","text":"<p>Counts clients who have at least one recorded session with a case manager or outreach worker</p> <p>Parameters:</p> Name Type Description Default <code>timeframe</code> <code>Bool</code> <p>whether to only count people who had at least one linkage between T1 and T2, defaults to True</p> <code>True</code> <code>cm_outreach</code> <p>which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"</p> <code>'cm'</code> <p>SQL Equivalent: </p> <pre><code>select count(distinct participant_id) from stints.classify_by_program \njoin civicore.case_sessions using(participant_id) \nwhere session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def programs_had_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n    Counts clients who have at least one recorded session with a case manager or outreach worker\n\n    Parameters:\n        timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n        cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n    SQL Equivalent: \n\n        select count(distinct participant_id) from stints.classify_by_program \n        join civicore.case_sessions using(participant_id) \n        where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n    '''\n    if cm_outreach.lower() == \"cm\":\n        cm_outreach = f'\"Casenote\"'\n    if cm_outreach.lower() == \"outreach\":\n        cm_outreach = f'\"Mentoring Session\"'\n    query = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n    if timeframe is True:\n        query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n    df = self.query_run(query)\n    return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.programs_packages","title":"<code>programs_packages()</code>","text":"<p>Provides counts and percentages of different program combinations</p> <p>SQL Equivalent:</p> <pre><code>WITH services_row as \n(SELECT participant_id,\n    GROUP_CONCAT(distinct CASE\n        WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n        END) AS Legal,\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n        END) AS \"CM\",\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n        END) AS YIP,\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n        END) AS SCaN,\n    GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n        ELSE NULL\n        END) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT CASE\n        WHEN hd = 1 THEN 'HD'\n        ELSE NULL\n        END) AS HD,\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN rjcc = 1 THEN 'RJCC'\n        ELSE NULL\n        END) AS RJCC,\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN crws = 1 THEN 'CRwS'\n        ELSE NULL\n        END) AS CRwS,\n    GROUP_CONCAT(distinct CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END) AS VP\nFROM stints.classify_by_program\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n    OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n    OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n    ) AS concatenated_services\nFROM (services_row))\nselect concatenated_services, count(concatenated_services), \ncount(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n\n\n        SQL Equivalent:\n\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n\n        '''\n        query = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\n\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\n\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.programs_rct_neighborhoods","title":"<code>programs_rct_neighborhoods()</code>","text":"<p>Returns a breakdown of RCT involvement by neighborhood</p> <p>SQL Equivalent:</p> <pre><code>select\n    count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n    count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n    count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n    count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n    count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n    count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom stints.classify_by_program;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n\n        SQL Equivalent:\n\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\n        query = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\n        df = self.query_run(query)\n        return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.programs_service_tally","title":"<code>programs_service_tally(service_column)</code>","text":"<p>Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service</p> <p>Parameters:</p> Name Type Description Default <code>Service</code> <code>column</code> <p>the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")</p> required <p>SQL Equivalent: </p> <pre><code>select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def programs_service_tally(self, service_column):\n'''\n    Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n\n    Parameters:\n        Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n\n\n    SQL Equivalent: \n\n        select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n    '''\n    if service_column.lower() == \"outreach\":\n        query = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\n    else:\n        query = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\n\n    df = self.query_run(query)\n    return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.programs_session_length","title":"<code>programs_session_length(cm_outreach='cm', grouped=False, timeframe=True)</code>","text":"<p>Finds the length of case management or outreach sessions</p> <p>Parameters:</p> Name Type Description Default <code>cm_outreach</code> <p>\"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"</p> <code>'cm'</code> <code>grouped(Bool)</code> <p>True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False</p> required <code>timeframe</code> <code>Bool</code> <p>whether to only count people who had at least one linkage between T1 and T2, defaults to True</p> <code>True</code> <p>SQL Equivalent:</p> <pre><code>select \n    avg(hours) * 60 as overall,\n    avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \nfrom stints.classify_by_program\njoin civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>def programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n    Finds the length of case management or outreach sessions\n\n    Parameters:\n        cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n        grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n        timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n\n    SQL Equivalent:\n\n        select \n            avg(hours) * 60 as overall,\n            avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n        from stints.classify_by_program\n        join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n    '''\n    if cm_outreach == \"cm\":\n        cm_outreach = f'\"Casenote\"'\n    if cm_outreach == \"outreach\":\n        cm_outreach = f'\"Mentoring Session\"'\n    if grouped is False:\n        query = f'''select \n        avg(hours) * 60 as overall,\n     avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\n        if timeframe is True:\n            query = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\n    if grouped is True:\n        if timeframe is True:  \n            query = f'''with hr_avg as (select \n    c.*,\n    case \n    when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n    when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n    when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n    when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n    when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n    when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n    when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n    when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n    when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n    when hours &gt; 2 then \"2+\"\n    end as session_length\nfrom {self.table}\njoin civicore.case_sessions c using(participant_id)\nwhere session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\n\nselect session_length, count(session_length)\nfrom hr_avg\ngroup by session_length\norder by case when session_length = '0' then 1\n            when session_length = '0-.25' then 2\n            when session_length = '.26-.5' then 3\n            when session_length = '.51-.75' then 4\n            when session_length = '.76-1' then 5\n            when session_length = '1-1.25' then 6\n            when session_length = '1.26-1.5' then 7\n            when session_length = '1.51-1.75' then 8\n            when session_length = '1.76-2' then 9\n            when session_length = '2+' then 10\n            else 0\n            end asc'''\n        else: \n            query = f'''with hr_avg as (select \n    c.*,\n    case \n    when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n    when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n    when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n    when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n    when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n    when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n    when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n    when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n    when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n    when hours &gt; 2 then \"2+\"\n    end as session_length\nfrom {self.table}\njoin civicore.case_sessions c using(participant_id)\nwhere session_casenote = {cm_outreach})\n\nselect session_length, count(session_length)\nfrom hr_avg\ngroup by session_length\norder by case when session_length = '0' then 1\n            when session_length = '0-.25' then 2\n            when session_length = '.26-.5' then 3\n            when session_length = '.51-.75' then 4\n            when session_length = '.76-1' then 5\n            when session_length = '1-1.25' then 6\n            when session_length = '1.26-1.5' then 7\n            when session_length = '1.51-1.75' then 8\n            when session_length = '1.76-2' then 9\n            when session_length = '2+' then 10\n            else 0\n            end asc'''\n    df = self.query_run(query)\n    return df\n</code></pre>"},{"location":"tables_ref/#script.meat.Queries.programs_session_tally","title":"<code>programs_session_tally(cm_outreach='cm')</code>","text":"<p>Counts successful and unsuccessful sessions among outreach or case managers</p> <p>Parameters:</p> Name Type Description Default <code>cm_outreach</code> <p>which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"</p> <code>'cm'</code> <p>SQL Equivalent:</p> <pre><code>select \n    COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \nfrom stints.classify_by_program\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n</code></pre> Source code in <code>script\\meat.py</code> <pre><code>    def programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n\n        SQL Equivalent:\n\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\n        if cm_outreach.lower() == \"cm\":\n            cm_outreach = f'\"Casenote\"'\n        if cm_outreach.lower() == \"outreach\":\n            cm_outreach = f'\"Mentoring Session\"'\n        query = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\n        df = self.query_run(query)\n        return df\n</code></pre>"}]}