{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>someday I will write this out with more vim</p> <p>check out Query Guide for examples of general SQL queries &amp; queries for groups of clients</p> <p>go to Examples if you'd like examples</p>"},{"location":"grants/","title":"Grant/Group Specific Queries","text":""},{"location":"grants/#a2j","title":"A2J","text":"<pre><code>a = A2J(t1 = '2023-12-01', t2 = '2023-12-31', print_SQL = True, \nclipboard = True)\n</code></pre> <p>             Bases: <code>Queries</code></p> <p>Sets up a table for running A2J reports</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <p>start of the stint (formatted: \"YYYY-MM-DD\")</p> required <code>t2</code> <p>end of the stint (formatted: \"YYYY-MM-DD\")</p> required Source code in <code>script\\nice_sql.py</code> <pre><code>class A2J(Queries):\n'''\n    Sets up a table for running A2J reports\n    Parameters:\n        t1: start of the stint (formatted: \"YYYY-MM-DD\")\n        t2: end of the stint (formatted: \"YYYY-MM-DD\")\n    '''\nreport_funcs = {\n\"CASES_STARTED\": (\"cases\", (\"ended\",)),\n\"CASES_ENDED\": (\"cases\", (\"started\",)),\n\"LINKAGES\": (\"linkages\", ())\n}\ndef __init__(self, t1, t2, default_table=\"stints.classify_by_program\"):\nsuper().__init__(t1, t2, default_table)\nself.table_update(\"a2j\", update_default_table= True)\ndef cases(self, started_ended = \"started\"):\n'''\n        counts legal cases for A2J that either started or ended\n        Parameters:\n            started_ended: \"started\" counts cases started, \"ended\" is cases ended. Defaults to \"started\" \n        '''\nif started_ended.lower()== \"started\":\nstarted_ended = \"arrest_date\"\nelse:\nstarted_ended = \"case_outcome_date\"\nquery = f'''select {self.table}.*, o.offense_date, o.case_outcome_date, o.case_outcome, o.sentence\nfrom participants.a2j\njoin civicore.legal o using(participant_id)\nwhere {started_ended} between {self.q_t1} and {self.q_t2}'''\ndf = self.query_run(query)\nreturn df\ndef linkages(self):\n'''\n        Counts linkages for A2J\n        '''\nquery = f'''select a.*, linkage_type, linkage_org, goal_area\nfrom {self.table} a\njoin civicore.linkages l using(participant_id)\nwhere linked_date between {self.q_t1} and {self.q_t2}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.A2J.cases","title":"<code>cases(started_ended='started')</code>","text":"<p>counts legal cases for A2J that either started or ended</p> <p>Parameters:</p> Name Type Description Default <code>started_ended</code> <p>\"started\" counts cases started, \"ended\" is cases ended. Defaults to \"started\"</p> <code>'started'</code> Source code in <code>script\\nice_sql.py</code> <pre><code>    def cases(self, started_ended = \"started\"):\n'''\n        counts legal cases for A2J that either started or ended\n        Parameters:\n            started_ended: \"started\" counts cases started, \"ended\" is cases ended. Defaults to \"started\" \n        '''\nif started_ended.lower()== \"started\":\nstarted_ended = \"arrest_date\"\nelse:\nstarted_ended = \"case_outcome_date\"\nquery = f'''select {self.table}.*, o.offense_date, o.case_outcome_date, o.case_outcome, o.sentence\nfrom participants.a2j\njoin civicore.legal o using(participant_id)\nwhere {started_ended} between {self.q_t1} and {self.q_t2}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.A2J.linkages","title":"<code>linkages()</code>","text":"<p>Counts linkages for A2J</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def linkages(self):\n'''\n        Counts linkages for A2J\n        '''\nquery = f'''select a.*, linkage_type, linkage_org, goal_area\nfrom {self.table} a\njoin civicore.linkages l using(participant_id)\nwhere linked_date between {self.q_t1} and {self.q_t2}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#running-reports","title":"Running Reports","text":"<pre><code>a = A2J(t1 = '2023-12-01', t2 = '2023-12-31', print_SQL = True, \nclipboard = True)\na.run_report(a.report_funcs)\n</code></pre>"},{"location":"grants/#report_funcs","title":"report_funcs","text":"<ul> <li>CASES_STARTED: <code>(\"cases\", (\"ended\",))</code></li> <li>CASES_ENDED: <code>(\"cases\", (\"started\",))</code></li> <li>LINKAGES: <code>(\"linkages\", ())</code></li> </ul>"},{"location":"grants/#jac-and-idhs","title":"JAC and IDHS","text":"<pre><code>j = JAC_IDHS(t1 = '2023-10-01', t2 = '2023-12-31', print_SQL = True, \nclipboard = True, grant = \"jac\")\n</code></pre> <p>             Bases: <code>Queries</code></p> <p>Sets up a table for running JAC/IDHS reports</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <p>start of the stint (formatted: \"YYYY-MM-DD\")</p> required <code>t2</code> <p>end of the stint (formatted: \"YYYY-MM-DD\")</p> required <code>print_sql</code> <p>whether to print the SQL statements when run, defaults to True</p> required <code>clipboard</code> <p>whether to copy the output table to your clipboard, defaults to False</p> <code>False</code> <code>grant</code> <p>which grant to include, either \"jac\" or \"idhs\"</p> <code>'idhs'</code> Source code in <code>script\\nice_sql.py</code> <pre><code>class JAC_IDHS(Queries):\n\"\"\"   \n    Sets up a table for running JAC/IDHS reports\n    Parameters:\n        t1: start of the stint (formatted: \"YYYY-MM-DD\")\n        t2: end of the stint (formatted: \"YYYY-MM-DD\")\n        print_sql: whether to print the SQL statements when run, defaults to True\n        clipboard: whether to copy the output table to your clipboard, defaults to False\n        grant: which grant to include, either \"jac\" or \"idhs\"\n        \"\"\"\nJAC_Smartsheet = {\n'participant count': (\"idhs_tally\",()),\n'genders': ('dem_race_gender',(False,'gender',)),\n'races': ('dem_race_gender',(False, 'race',)),\n'ages': ('dem_age',()),\n'services': ('idhs_service_tally',()),\n'avg hours spent on CM': ('jac_cm_hours',()),\n'avg number of CM sessions': ('jac_cm_sessions',()),\n'transportation assistance': ('jac_transpo_assist',()),\n'connected to other providers': ('jac_linked_participant_tally', ()),\n'referrals': ('idhs_linkages',())\n}\nCVI = {\n'total participants': ('idhs_tally',()),\n'ages': ('idhs_ages',()),\n'races': ('idhs_race_gender', ('race',)),\n'genders': ('idhs_race_gender', ('gender',)),\n'languages': ('idhs_language',()),\n'services':('idhs_service_tally',()),\n'referrals':('idhs_linkages',()),\n'number of mediations': ('mediation_tally',()),\n'CPIC notifications': ('idhs_incidents_detailed', (True,)),\n'non-CPIC notifications': ('idhs_incidents_detailed', (False,)),\n'time spent on mediations': ('mediation_time_spent',())\n}\nPPR = {'new and continuing clients': ('idhs_tally', (False,)),\n'closed clients': ('idhs_tally', (True,)),\n'outreach and legal': ('idhs_service_tally',()),\n'race': ('dem_race_gender', (False, 'race',)),\n'gender': ('dem_race_gender', (False, 'gender',)),\n'ages': ('idhs_ages', (True,)),\n'eligibility': ('idhs_class_notes',(True,)),\n'cm linkages': ('idhs_linkages',()),\n'initial mediations': ('mediation_tally', (False,)),\n'followup mediations': ('mediation_tally', (True,)),\n'incidents': ('incident_tally',())\n}\ndef __init__(self, t1, t2, print_SQL = True, clipboard = False, default_table=\"stints.classify_by_program\", grant = 'idhs'):\nsuper().__init__(t1, t2, print_SQL, clipboard, default_table)\nif grant.lower() == \"idhs\":\nself.program = 'idhs'\nself.table_update(\"idhs\", update_default_table= True)\nif grant.lower() == \"jac\":\nself.program = 'jac'\nself.table_update(\"jac\", update_default_table= True)\ndef idhs_ages(self, PPR = False):\n'''\n        Returns ages of IDHS clients in the desired grouping\n        Parameters:\n            PPR: if True, groups according to PPR age breakdown. Defaults to False\n        '''\nif PPR == False:\nquery = f'''select \n        new_client,\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 0 AND 17 then participant_id else null end) as \"Under 18\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as \"18 to 24\"\n    from {self.table}\n    join civicore.participants using(participant_id)\n    group by new_client'''\nelse:\nquery = f'''select \n        new_client,\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 0 AND 5 then participant_id else null end) as \"0 to 5\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 6 AND 10 then participant_id else null end) as \"6 to 10\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 11 AND 13 then participant_id else null end) as \"11 to 13\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 14 AND 17 then participant_id else null end) as \"14 to 17\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as \"18 to 24\"\n    from {self.table}\n    join civicore.participants using(participant_id)\n    group by new_client\n'''\ndf = self.query_run(query)\nreturn df\ndef idhs_tally(self, closed = False):\n'''\n        counts number of people on grant\n        Parameters:\n            closed(Bool): if True, only returns closed clients. Defaults to False\n        '''\nif closed is False: \nquery = f'''select new_client, count(distinct participant_id)\n    from {self.table}\n    group by new_client'''\nelse:\nquery = f'''select count(distinct participant_id) from {self.table}\nwhere end_date between {self.q_t1} and {self.q_t2} or (closed_date between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\ndef idhs_class_notes(self, new = False):\n'''\n        returns those eligibility acronyms\n        Parameters:\n            new(Bool): if True, only returns new clients. Defaults to False\n        '''\nif new == False:\nquery = f'''with class as (select * from (select distinct participant_id\n    from {self.table}) j\n    join civicore.classes using(participant_id)\n    where class regexp '2023 IDHS VP.*' and (unenroll_date is null or unenroll_date between {self.q_t1} and {self.q_t2}))\n    SELECT acronym, COUNT(*) AS count\n    FROM (\n        SELECT TRIM(REPLACE(REGEXP_SUBSTR(CAST(summary_note AS CHAR), '[[:alnum:]]+', 1, n.n), ' ', '')) AS acronym\n        FROM class\n        JOIN (\n            SELECT a.N + b.N * 10 + 1 AS n\n            FROM\n                (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) a,\n                (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) b\n            ORDER BY n\n        ) n ON CHAR_LENGTH(CAST(summary_note AS CHAR)) - CHAR_LENGTH(REGEXP_REPLACE(CAST(summary_note AS CHAR), '[[:alnum:]]+', '')) &gt;= n.n\n    ) AS Acronyms\n    WHERE acronym != ''\n    GROUP BY acronym'''\nif new == True:\nquery = f'''with class as (select * from (select distinct participant_id\n    from {self.table} where start_date &gt; {self.q_t1}) j\n    join civicore.classes using(participant_id)\n    where class regexp '2023 IDHS VP.*' and (unenroll_date is null or unenroll_date between {self.q_t1} and {self.q_t2}))\n    SELECT acronym, COUNT(*) AS count\n    FROM (\n        SELECT TRIM(REPLACE(REGEXP_SUBSTR(CAST(summary_note AS CHAR), '[[:alnum:]]+', 1, n.n), ' ', '')) AS acronym\n        FROM class\n        JOIN (\n            SELECT a.N + b.N * 10 + 1 AS n\n            FROM\n                (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) a,\n                (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) b\n            ORDER BY n\n        ) n ON CHAR_LENGTH(CAST(summary_note AS CHAR)) - CHAR_LENGTH(REGEXP_REPLACE(CAST(summary_note AS CHAR), '[[:alnum:]]+', '')) &gt;= n.n\n    ) AS Acronyms\n    WHERE acronym != ''\n    GROUP BY acronym'''\ndf = self.query_run(query)\nreturn df\ndef idhs_race_gender(self, race_gender = 'race'):\n'''\n        Returns count of race/gender, distinguishing between new/continuing clients\n        Parameters:\n            race_gender: 'race' returns client races, 'gender' returns client genders. Defaults to 'race'\n        '''\nquery = f'''select new_client, {race_gender}, count({race_gender})\nfrom {self.table}\njoin civicore.participants using(participant_id)\ngroup by new_client, {race_gender}'''\ndf = self.query_run(query)\nreturn df\ndef idhs_language(self):\n'''\n        counts participant primary languages\n        '''\nquery = f'''select new_client, language_primary, count(distinct participant_id)\nfrom {self.table}\njoin civicore.participants using(participant_id)\ngroup by new_client, language_primary'''\ndf = self.query_run(query)\nreturn df\ndef idhs_service_tally(self):\n'''\n        counts clients receiving services from the chosen grant\n        '''\nquery = f'''select new_client, count(distinct case when program_type regexp \".*{self.program} - Outreach.*\" then participant_id else null end) as outreach, \ncount(distinct case when program_type regexp \".*{self.program} - Case.*\" then participant_id else null end) as CM,\ncount(distinct case when program_type regexp \".*{self.program} - Legal.*\" then participant_id else null end) as legal\nfrom {self.table}\ngroup by new_client'''\ndf = self.query_run(query)\nreturn df\ndef idhs_linkages (self):\n'''\n        returns goal areas for clients receiving a grant's case management\n        '''\nquery = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_id, linkage_type, linkage_org, linked_date, hub_initiated, new_client, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, linkage_id, goal_area, linked_date, hub_initiated, new_client from (select * from \n{self.table}\nwhere program_type regexp '.*{self.program} - case.*') p\njoin civicore.linkages l using(participant_id) where hub_initiated = \"Yes\") s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\nselect separated_area, count(distinct case when new_client = \"new\" then linkage_id end) as new_links, count(distinct case when new_client = \"continuing\" then linkage_id end) as cont_links\nfrom separated_goals\nwhere linked_date between {self.q_t1} and {self.q_t2}\ngroup by separated_area'''\ndf = self.query_run(query)\nreturn df\ndef idhs_incidents_detailed(self, CPIC = True):\n'''\n        returns incident analysis. need to update code to specify neighborhoods.\n        '''\nif CPIC == True:\nquery = f'''SELECT type_incident,\ncount(case when num_deceased &gt; 0 then incident_id else null end) as fatal,\ncount(case when num_deceased = 0 then incident_id else null end) as non_fatal\nFROM civicore.critical_incidents\nwhere how_hear regexp '.*cpic.*' and date_incident between {self.q_t1} and {self.q_t2}\ngroup by type_incident'''\nelse:\nquery = f'''select how_hear, count(incident_id) from civicore.critical_incidents\nwhere date_incident between {self.q_t1} and {self.q_t2} and how_hear not regexp '.*cpic.*'\ngroup by how_hear'''\ndf = self.query_run(query)\nreturn df\ndef jac_cm_hours(self):\n'''\n        gets average case management hours for JAC clients\n        '''\nquery = f'''select avg(hours) as overall_avg from\n(select participant_id, sum(hours) as hours from \n(select distinct participant_id \nfrom {self.table}\nwhere program_type REGEXP '.*{self.program} - Case Management.*') l\njoin civicore.case_sessions using(participant_id)\nwhere session_date BETWEEN {self.q_t1} and {self.q_t2} AND session_casenote = \"casenote\"\ngroup by participant_id) ll'''\ndf = self.query_run(query)\nreturn df\ndef jac_cm_sessions(self):\n'''\n        gets average case management sessions for JAC clients\n        '''\nquery = f'''select count(distinct case_session_id)/count(distinct participant_id) from (select * from (select distinct participant_id \nfrom {self.table}\nwhere program_type REGEXP '.*{self.program} - Case Management.*') l\njoin civicore.case_sessions using(participant_id)\nwhere session_date BETWEEN {self.q_t1} and {self.q_t2} AND session_casenote = \"casenote\" and hours &gt; 0 and (indirect_type != 'Unsuccessful Attempt' or indirect_type IS NULL)) ll;'''\ndf = self.query_run(query)\nreturn df\ndef jac_transpo_assist(self):\n'''\n        counts clients marked as both jac and CRwS\n        '''\nquery = f'''select count(distinct participant_id)\nfrom participants.jac\nwhere program_type like \"%JAC%\" and crws = 1'''\ndf = self.query_run(query)\nreturn df\ndef jac_linked_participant_tally(self):\n'''\n        counts jac participants with a started linkage\n        '''\nquery = f'''select count(distinct participant_id) from participants.jac\njoin civicore.linkages l using (participant_id)\nwhere l.start_date IS NOT NULL'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.idhs_ages","title":"<code>idhs_ages(PPR=False)</code>","text":"<p>Returns ages of IDHS clients in the desired grouping</p> <p>Parameters:</p> Name Type Description Default <code>PPR</code> <p>if True, groups according to PPR age breakdown. Defaults to False</p> <code>False</code> Source code in <code>script\\nice_sql.py</code> <pre><code>    def idhs_ages(self, PPR = False):\n'''\n        Returns ages of IDHS clients in the desired grouping\n        Parameters:\n            PPR: if True, groups according to PPR age breakdown. Defaults to False\n        '''\nif PPR == False:\nquery = f'''select \n        new_client,\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 0 AND 17 then participant_id else null end) as \"Under 18\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as \"18 to 24\"\n    from {self.table}\n    join civicore.participants using(participant_id)\n    group by new_client'''\nelse:\nquery = f'''select \n        new_client,\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 0 AND 5 then participant_id else null end) as \"0 to 5\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 6 AND 10 then participant_id else null end) as \"6 to 10\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 11 AND 13 then participant_id else null end) as \"11 to 13\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 14 AND 17 then participant_id else null end) as \"14 to 17\",\n        count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as \"18 to 24\"\n    from {self.table}\n    join civicore.participants using(participant_id)\n    group by new_client\n'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.idhs_class_notes","title":"<code>idhs_class_notes(new=False)</code>","text":"<p>returns those eligibility acronyms</p> <p>Parameters:</p> Name Type Description Default <code>new(Bool)</code> <p>if True, only returns new clients. Defaults to False</p> required Source code in <code>script\\nice_sql.py</code> <pre><code>def idhs_class_notes(self, new = False):\n'''\n    returns those eligibility acronyms\n    Parameters:\n        new(Bool): if True, only returns new clients. Defaults to False\n    '''\nif new == False:\nquery = f'''with class as (select * from (select distinct participant_id\nfrom {self.table}) j\njoin civicore.classes using(participant_id)\nwhere class regexp '2023 IDHS VP.*' and (unenroll_date is null or unenroll_date between {self.q_t1} and {self.q_t2}))\nSELECT acronym, COUNT(*) AS count\nFROM (\n    SELECT TRIM(REPLACE(REGEXP_SUBSTR(CAST(summary_note AS CHAR), '[[:alnum:]]+', 1, n.n), ' ', '')) AS acronym\n    FROM class\n    JOIN (\n        SELECT a.N + b.N * 10 + 1 AS n\n        FROM\n            (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) a,\n            (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) b\n        ORDER BY n\n    ) n ON CHAR_LENGTH(CAST(summary_note AS CHAR)) - CHAR_LENGTH(REGEXP_REPLACE(CAST(summary_note AS CHAR), '[[:alnum:]]+', '')) &gt;= n.n\n) AS Acronyms\nWHERE acronym != ''\nGROUP BY acronym'''\nif new == True:\nquery = f'''with class as (select * from (select distinct participant_id\nfrom {self.table} where start_date &gt; {self.q_t1}) j\njoin civicore.classes using(participant_id)\nwhere class regexp '2023 IDHS VP.*' and (unenroll_date is null or unenroll_date between {self.q_t1} and {self.q_t2}))\nSELECT acronym, COUNT(*) AS count\nFROM (\n    SELECT TRIM(REPLACE(REGEXP_SUBSTR(CAST(summary_note AS CHAR), '[[:alnum:]]+', 1, n.n), ' ', '')) AS acronym\n    FROM class\n    JOIN (\n        SELECT a.N + b.N * 10 + 1 AS n\n        FROM\n            (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) a,\n            (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3) b\n        ORDER BY n\n    ) n ON CHAR_LENGTH(CAST(summary_note AS CHAR)) - CHAR_LENGTH(REGEXP_REPLACE(CAST(summary_note AS CHAR), '[[:alnum:]]+', '')) &gt;= n.n\n) AS Acronyms\nWHERE acronym != ''\nGROUP BY acronym'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.idhs_incidents_detailed","title":"<code>idhs_incidents_detailed(CPIC=True)</code>","text":"<p>returns incident analysis. need to update code to specify neighborhoods.</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def idhs_incidents_detailed(self, CPIC = True):\n'''\n        returns incident analysis. need to update code to specify neighborhoods.\n        '''\nif CPIC == True:\nquery = f'''SELECT type_incident,\ncount(case when num_deceased &gt; 0 then incident_id else null end) as fatal,\ncount(case when num_deceased = 0 then incident_id else null end) as non_fatal\nFROM civicore.critical_incidents\nwhere how_hear regexp '.*cpic.*' and date_incident between {self.q_t1} and {self.q_t2}\ngroup by type_incident'''\nelse:\nquery = f'''select how_hear, count(incident_id) from civicore.critical_incidents\nwhere date_incident between {self.q_t1} and {self.q_t2} and how_hear not regexp '.*cpic.*'\ngroup by how_hear'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.idhs_language","title":"<code>idhs_language()</code>","text":"<p>counts participant primary languages</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def idhs_language(self):\n'''\n        counts participant primary languages\n        '''\nquery = f'''select new_client, language_primary, count(distinct participant_id)\nfrom {self.table}\njoin civicore.participants using(participant_id)\ngroup by new_client, language_primary'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.idhs_linkages","title":"<code>idhs_linkages()</code>","text":"<p>returns goal areas for clients receiving a grant's case management</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def idhs_linkages (self):\n'''\n        returns goal areas for clients receiving a grant's case management\n        '''\nquery = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_id, linkage_type, linkage_org, linked_date, hub_initiated, new_client, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, linkage_id, goal_area, linked_date, hub_initiated, new_client from (select * from \n{self.table}\nwhere program_type regexp '.*{self.program} - case.*') p\njoin civicore.linkages l using(participant_id) where hub_initiated = \"Yes\") s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\nselect separated_area, count(distinct case when new_client = \"new\" then linkage_id end) as new_links, count(distinct case when new_client = \"continuing\" then linkage_id end) as cont_links\nfrom separated_goals\nwhere linked_date between {self.q_t1} and {self.q_t2}\ngroup by separated_area'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.idhs_race_gender","title":"<code>idhs_race_gender(race_gender='race')</code>","text":"<p>Returns count of race/gender, distinguishing between new/continuing clients</p> <p>Parameters:</p> Name Type Description Default <code>race_gender</code> <p>'race' returns client races, 'gender' returns client genders. Defaults to 'race'</p> <code>'race'</code> Source code in <code>script\\nice_sql.py</code> <pre><code>    def idhs_race_gender(self, race_gender = 'race'):\n'''\n        Returns count of race/gender, distinguishing between new/continuing clients\n        Parameters:\n            race_gender: 'race' returns client races, 'gender' returns client genders. Defaults to 'race'\n        '''\nquery = f'''select new_client, {race_gender}, count({race_gender})\nfrom {self.table}\njoin civicore.participants using(participant_id)\ngroup by new_client, {race_gender}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.idhs_service_tally","title":"<code>idhs_service_tally()</code>","text":"<p>counts clients receiving services from the chosen grant</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def idhs_service_tally(self):\n'''\n        counts clients receiving services from the chosen grant\n        '''\nquery = f'''select new_client, count(distinct case when program_type regexp \".*{self.program} - Outreach.*\" then participant_id else null end) as outreach, \ncount(distinct case when program_type regexp \".*{self.program} - Case.*\" then participant_id else null end) as CM,\ncount(distinct case when program_type regexp \".*{self.program} - Legal.*\" then participant_id else null end) as legal\nfrom {self.table}\ngroup by new_client'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.idhs_tally","title":"<code>idhs_tally(closed=False)</code>","text":"<p>counts number of people on grant</p> <p>Parameters:</p> Name Type Description Default <code>closed(Bool)</code> <p>if True, only returns closed clients. Defaults to False</p> required Source code in <code>script\\nice_sql.py</code> <pre><code>    def idhs_tally(self, closed = False):\n'''\n        counts number of people on grant\n        Parameters:\n            closed(Bool): if True, only returns closed clients. Defaults to False\n        '''\nif closed is False: \nquery = f'''select new_client, count(distinct participant_id)\n    from {self.table}\n    group by new_client'''\nelse:\nquery = f'''select count(distinct participant_id) from {self.table}\nwhere end_date between {self.q_t1} and {self.q_t2} or (closed_date between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.jac_cm_hours","title":"<code>jac_cm_hours()</code>","text":"<p>gets average case management hours for JAC clients</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def jac_cm_hours(self):\n'''\n        gets average case management hours for JAC clients\n        '''\nquery = f'''select avg(hours) as overall_avg from\n(select participant_id, sum(hours) as hours from \n(select distinct participant_id \nfrom {self.table}\nwhere program_type REGEXP '.*{self.program} - Case Management.*') l\njoin civicore.case_sessions using(participant_id)\nwhere session_date BETWEEN {self.q_t1} and {self.q_t2} AND session_casenote = \"casenote\"\ngroup by participant_id) ll'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.jac_cm_sessions","title":"<code>jac_cm_sessions()</code>","text":"<p>gets average case management sessions for JAC clients</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def jac_cm_sessions(self):\n'''\n        gets average case management sessions for JAC clients\n        '''\nquery = f'''select count(distinct case_session_id)/count(distinct participant_id) from (select * from (select distinct participant_id \nfrom {self.table}\nwhere program_type REGEXP '.*{self.program} - Case Management.*') l\njoin civicore.case_sessions using(participant_id)\nwhere session_date BETWEEN {self.q_t1} and {self.q_t2} AND session_casenote = \"casenote\" and hours &gt; 0 and (indirect_type != 'Unsuccessful Attempt' or indirect_type IS NULL)) ll;'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.jac_linked_participant_tally","title":"<code>jac_linked_participant_tally()</code>","text":"<p>counts jac participants with a started linkage</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def jac_linked_participant_tally(self):\n'''\n        counts jac participants with a started linkage\n        '''\nquery = f'''select count(distinct participant_id) from participants.jac\njoin civicore.linkages l using (participant_id)\nwhere l.start_date IS NOT NULL'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.JAC_IDHS.jac_transpo_assist","title":"<code>jac_transpo_assist()</code>","text":"<p>counts clients marked as both jac and CRwS</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def jac_transpo_assist(self):\n'''\n        counts clients marked as both jac and CRwS\n        '''\nquery = f'''select count(distinct participant_id)\nfrom participants.jac\nwhere program_type like \"%JAC%\" and crws = 1'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#running-reports_1","title":"Running Reports","text":"<pre><code>j = JAC_IDHS(t1 = '2023-12-01', t2 = '2023-12-31', print_SQL = True, \nclipboard = True, grant = 'jac')\nj.run_report(j.JAC_Smartsheet)\nj.run_report(j.CVI)\nj.run_report(j.PPR)\n</code></pre>"},{"location":"grants/#jac_smartsheet","title":"JAC_Smartsheet","text":"<ul> <li>participant count: <code>(\"idhs_tally\",())</code></li> <li>genders: <code>('dem_race_gender', (False,'gender',))</code></li> <li>races: <code>('dem_race_gender', (False, 'race',))</code></li> <li>ages: <code>('dem_age',())</code></li> <li>services: <code>('idhs_service_tally',())</code></li> <li>avg hours spent on CM: <code>('jac_cm_hours',())</code></li> <li>avg number of CM sessions: <code>('jac_cm_sessions',())</code></li> <li>transportation assistance: <code>('jac_transpo_assist',())</code></li> <li>connected to other providers: <code>('jac_linked_participant_tally', ())</code></li> <li>referrals: <code>('idhs_linkages',())</code></li> </ul>"},{"location":"grants/#cvi","title":"CVI","text":"<ul> <li>total participants: <code>('idhs_tally',())</code></li> <li>ages: <code>('idhs_ages',())</code></li> <li>races: <code>('idhs_race_gender', ('race',))</code></li> <li>genders: <code>('idhs_race_gender', ('gender',))</code></li> <li>languages: <code>('idhs_language',())</code></li> <li>services: <code>('idhs_service_tally',())</code></li> <li>referrals: <code>('idhs_linkages',())</code></li> <li>number of mediations: <code>('mediation_tally',())</code></li> <li>CPIC notifications: <code>('idhs_incidents_detailed', (True,))</code></li> <li>non-CPIC notifications: <code>('idhs_incidents_detailed', (False,))</code></li> <li>time spent on mediations: <code>('mediation_time_spent',())</code></li> </ul>"},{"location":"grants/#ppr","title":"PPR","text":"<ul> <li>new and continuing clients: <code>('idhs_tally', (False,))</code></li> <li>closed clients: <code>('idhs_tally', (True,))</code></li> <li>outreach and legal: <code>('idhs_service_tally',())</code></li> <li>race: <code>('dem_race_gender', (False, 'race',))</code></li> <li>gender: <code>('dem_race_gender', (False, 'gender',))</code></li> <li>ages: <code>('idhs_ages', (True,))</code></li> <li>eligibility: <code>('idhs_class_notes',(True,))</code></li> <li>cm linkages: <code>('idhs_linkages',())</code></li> <li>initial mediations: <code>('mediation_tally', (False,))</code></li> <li>followup mediations: <code>('mediation_tally', (True,))</code></li> <li>incidents: <code>('incident_tally',())</code></li> </ul>"},{"location":"grants/#monthly-reports","title":"Monthly Reports","text":"<pre><code>m = Monthly_Report(t1 = '2023-12-01', t2 = '2023-12-31', print_SQL = True, \nclipboard = True)\n</code></pre> <p>             Bases: <code>Queries</code></p> Source code in <code>script\\nice_sql.py</code> <pre><code>class Monthly_Report(Queries):\nprogram_grant_funcs = {\n\"grant involvement\": (\"grant_tally\", ()),\n\"grants started\": (\"grant_tally\", (\"start_date\",)),\n\"grants ended\": (\"grant_tally\", (\"end_date\",)),\n\"Program Involvement by Days - All\": (\"grouped_by_time\", (\"program\", False,True,)),\n\"Program Involvement by Days - Closed\": (\"grouped_by_time\", (\"program\", True, True,)),\n\"PROGRAMS BY RACE\": (\"programs_by_demographic\",(\"race\", True,)),\n\"PROGRAMS BY GENDER\": (\"programs_by_demographic\",(\"gender\",True, )),\n\"PROGRAMS BY AGE\": (\"programs_by_demographic\",(\"age\",True,)),\n\"ALL_DAYS_SERVED_BY_GRANT\": (\"grouped_by_time\", (\"grant\", False,)),\n\"CLOSED_DAYS_SERVED_BY_GRANT\": (\"grouped_by_time\", (\"grant\", True,)),\n\"PACKAGE OF SERVICES\":(\"programs_packages\",()),\n}\nlegal_funcs = {\n\"CiviCore.Legal Tally\": (\"legal_tally\",()),\n\"Case Pending Tally\": (\"legal_tally\",(True,)),\n\"Case Type - All Cases\": (\"legal_case_type\", (False,False,\"opened\",True, \"case\")),\n\"Case Type - Opened\": (\"legal_case_type\", (False, True, \"opened\",\"case\")),\n\"Case Type - Closed\": (\"legal_case_type\", (False, True, \"closed\",\"case\")),\n\"Rearrested\": (\"legal_rearrested\",()),\n\"Pending Cases\": (\"legal_pending_cases\", (\"t2\",)),\n\"Case Outcomes\": (\"legal_case_outcomes\", ()),\n\"Guilty Plea Outcomes\": (\"legal_plea_outcomes\", (True,))\n}\ncm_outreach_funcs = {\n\"receiving CM\": (\"programs_service_tally\", (\"service_cm\",)),\n\"Had CM Session in Month\": (\"programs_sessions\", ()),\n\"CM Session Count\": (\"programs_session_tally\", (\"cm\",)),\n\"CM Session Length\": (\"programs_session_length\", ()),\n\"CM Session Length (Grouped)\": (\"programs_session_length\", (\"cm\", True, True)),\n\"Had Outreach Session in Month\": (\"programs_sessions\", (\"outreach\",)),\n\"Outreach Session Count\": (\"programs_session_tally\", (\"outreach\",)),\n\"linkage tally\": (\"link_tally\", (True, True, \"linked_date\",)),\n\"services linked\": (\"link_goal_area\", (True, True, \"both\",)) \n}\ndef __init__(self, t1, t2, default_table=\"stints.classify_by_program\"):\nsuper().__init__(t1, t2, default_table)\nself.table_update(\"mreport\", update_default_table= True)\ndef grouped_by_status(self, program_grant = \"grant\"):\n'''\n        Returns program or grant involvement by client status\n        Parameters:\n            program_grant: \"program\" tallies program involvement, \"grant\" tallies grant involvement. Defaults to \"grant\"\n        '''\nif program_grant == \"program\":\nquery = f'''select client_status, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN vp = 1 THEN participant_id END) AS vp,\n    COUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS\n    from {self.table}\n    group by client_status\n    UNION ALL\n    SELECT\n    \"new client\" as client_status,\n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN vp = 1 THEN participant_id END) AS vp,\n    COUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS\n    from {self.table}\n    where new_client = \"new client\"\n    ORDER BY case when client_status = 'active client' then 1\n    when client_status = 'new client' then 2\n    when client_status = 'closed out' then 3\n    end asc'''\nif program_grant == \"grant\":\nquery = f'''select client_status, \nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%A2J%\" THEN participant_id END) AS A2J,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%SCAN%\" THEN participant_id END) AS SCAN,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%CRwS%\" THEN participant_id END) AS CRwS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%YIP%\" THEN participant_id END) AS YIP\nfrom {self.table}\ngroup by client_status\nUNION ALL\nSELECT\n\t\"new client\" as client_status,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%A2J%\" THEN participant_id END) AS A2J,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%SCAN%\" THEN participant_id END) AS SCAN,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%CRwS%\" THEN participant_id END) AS CRwS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%YIP%\" THEN participant_id END) AS YIPS\nfrom {self.table}\nwhere new_client = \"new client\"\nORDER BY case when client_status = 'active client' then 1\n              when client_status = 'new client' then 2\n              when client_status = 'closed out' then 3\n              end asc'''\ndf = self.query_run(query)\nreturn df\ndef grouped_by_time(self, program_grant = \"grant\",closed_only = False, percentages = True):\n'''\n        Returns program or grant involvement by client status\n        Parameters:\n            program_grant: \"program\" tallies program involvement, \"grant\" tallies grant involvement. Defaults to \"grant\"\n            closed_only(Bool): True only tallies closed clients\n            percentages(Bool): True auto-converts to percentages. Defaults to True \n        '''\nif program_grant == \"program\":\nquery = f'''select days_served, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS\n    from {self.table}\n    group by days_served\n    ORDER BY case when days_served = '0-45' then 1\n    when days_served = '46-90' then 2\n    when days_served = '91-180' then 3\n    when days_served = '181-270' then 4\n    else 5\n    end asc'''\nif program_grant == \"grant\":\nquery = f'''select days_served, \nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%A2J%\" THEN participant_id END) AS A2J,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%SCAN%\" THEN participant_id END) AS SCAN,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%CRwS%\" THEN participant_id END) AS CRwS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%YIP%\" THEN participant_id END) AS YIP\nfrom {self.table}\ngroup by days_served\nORDER BY case when days_served = '0-45' then 1\nwhen days_served = '46-90' then 2\nwhen days_served = '91-180' then 3\nwhen days_served = '181-270' then 4\nelse 5\nend asc'''\nif closed_only == True:\nquery = self.query_modify(str(query), f'''where client_status = \"closed out\"''')\ndf = self.query_run(query)\nif percentages == True:\ndf = self.percentage_convert(df)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.Monthly_Report.grouped_by_status","title":"<code>grouped_by_status(program_grant='grant')</code>","text":"<p>Returns program or grant involvement by client status</p> <p>Parameters:</p> Name Type Description Default <code>program_grant</code> <p>\"program\" tallies program involvement, \"grant\" tallies grant involvement. Defaults to \"grant\"</p> <code>'grant'</code> Source code in <code>script\\nice_sql.py</code> <pre><code>    def grouped_by_status(self, program_grant = \"grant\"):\n'''\n        Returns program or grant involvement by client status\n        Parameters:\n            program_grant: \"program\" tallies program involvement, \"grant\" tallies grant involvement. Defaults to \"grant\"\n        '''\nif program_grant == \"program\":\nquery = f'''select client_status, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN vp = 1 THEN participant_id END) AS vp,\n    COUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS\n    from {self.table}\n    group by client_status\n    UNION ALL\n    SELECT\n    \"new client\" as client_status,\n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN vp = 1 THEN participant_id END) AS vp,\n    COUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS\n    from {self.table}\n    where new_client = \"new client\"\n    ORDER BY case when client_status = 'active client' then 1\n    when client_status = 'new client' then 2\n    when client_status = 'closed out' then 3\n    end asc'''\nif program_grant == \"grant\":\nquery = f'''select client_status, \nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%A2J%\" THEN participant_id END) AS A2J,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%SCAN%\" THEN participant_id END) AS SCAN,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%CRwS%\" THEN participant_id END) AS CRwS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%YIP%\" THEN participant_id END) AS YIP\nfrom {self.table}\ngroup by client_status\nUNION ALL\nSELECT\n\t\"new client\" as client_status,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%A2J%\" THEN participant_id END) AS A2J,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%SCAN%\" THEN participant_id END) AS SCAN,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%CRwS%\" THEN participant_id END) AS CRwS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%YIP%\" THEN participant_id END) AS YIPS\nfrom {self.table}\nwhere new_client = \"new client\"\nORDER BY case when client_status = 'active client' then 1\n              when client_status = 'new client' then 2\n              when client_status = 'closed out' then 3\n              end asc'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"grants/#script.nice_sql.Monthly_Report.grouped_by_time","title":"<code>grouped_by_time(program_grant='grant', closed_only=False, percentages=True)</code>","text":"<p>Returns program or grant involvement by client status</p> <p>Parameters:</p> Name Type Description Default <code>program_grant</code> <p>\"program\" tallies program involvement, \"grant\" tallies grant involvement. Defaults to \"grant\"</p> <code>'grant'</code> <code>closed_only(Bool)</code> <p>True only tallies closed clients</p> required <code>percentages(Bool)</code> <p>True auto-converts to percentages. Defaults to True</p> required Source code in <code>script\\nice_sql.py</code> <pre><code>    def grouped_by_time(self, program_grant = \"grant\",closed_only = False, percentages = True):\n'''\n        Returns program or grant involvement by client status\n        Parameters:\n            program_grant: \"program\" tallies program involvement, \"grant\" tallies grant involvement. Defaults to \"grant\"\n            closed_only(Bool): True only tallies closed clients\n            percentages(Bool): True auto-converts to percentages. Defaults to True \n        '''\nif program_grant == \"program\":\nquery = f'''select days_served, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS\n    from {self.table}\n    group by days_served\n    ORDER BY case when days_served = '0-45' then 1\n    when days_served = '46-90' then 2\n    when days_served = '91-180' then 3\n    when days_served = '181-270' then 4\n    else 5\n    end asc'''\nif program_grant == \"grant\":\nquery = f'''select days_served, \nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%A2J%\" THEN participant_id END) AS A2J,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%IDHS%\" THEN participant_id END) AS IDHS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%JAC%\" THEN participant_id END) AS JAC,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%SCAN%\" THEN participant_id END) AS SCAN,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%CRwS%\" THEN participant_id END) AS CRwS,\nCOUNT(DISTINCT CASE WHEN grant_type LIKE \"%YIP%\" THEN participant_id END) AS YIP\nfrom {self.table}\ngroup by days_served\nORDER BY case when days_served = '0-45' then 1\nwhen days_served = '46-90' then 2\nwhen days_served = '91-180' then 3\nwhen days_served = '181-270' then 4\nelse 5\nend asc'''\nif closed_only == True:\nquery = self.query_modify(str(query), f'''where client_status = \"closed out\"''')\ndf = self.query_run(query)\nif percentages == True:\ndf = self.percentage_convert(df)\nreturn df\n</code></pre>"},{"location":"grants/#running-reports_2","title":"Running Reports","text":"<pre><code> m = Monthly_Report(t1 = '2023-12-01', t2 = '2023-12-31', print_SQL = True, \nclipboard = True)\nm.run_report(program_grant_funcs)\nm.run_report(legal_funcs)\nm.run_report(cm_outreach_funcs)\n</code></pre>"},{"location":"grants/#program_grant_funcs","title":"program_grant_funcs","text":"<ul> <li>grant involvement: <code>(\"grant_tally\", ())</code></li> <li>grants started: <code>(\"grant_tally\", (\"start_date\",))</code></li> <li>grants ended: <code>(\"grant_tally\", (\"end_date\",))</code></li> <li>Program Involvement by Days - All: <code>(\"grouped_by_time\", (\"program\", False, True,))</code></li> <li>Program Involvement by Days - Closed: <code>(\"grouped_by_time\", (\"program\", True, True,))</code></li> <li>PROGRAMS BY RACE: <code>(\"programs_by_demographic\",(\"race\", True,))</code></li> <li>PROGRAMS BY GENDER: <code>(\"programs_by_demographic\",(\"gender\", True, ))</code></li> <li>PROGRAMS BY AGE: <code>(\"programs_by_demographic\",(\"age\", True,))</code></li> <li>ALL_DAYS_SERVED_BY_GRANT: <code>(\"grouped_by_time\", (\"grant\", False,))</code></li> <li>CLOSED_DAYS_SERVED_BY_GRANT: <code>(\"grouped_by_time\", (\"grant\", True,))</code></li> <li>PACKAGE OF SERVICES: <code>(\"programs_packages\",())</code></li> </ul>"},{"location":"grants/#legal_funcs","title":"legal_funcs","text":"<ul> <li>CiviCore.Legal Tally: <code>(\"legal_tally\",())</code></li> <li>Case Pending Tally: <code>(\"legal_tally\",(True,))</code></li> <li>Case Type - All Cases: <code>(\"legal_case_type\", (False, False, \"opened\", True, \"case\"))</code></li> <li>Case Type - Opened: <code>(\"legal_case_type\", (False, True, \"opened\",\"case\"))</code></li> <li>Case Type - Closed: <code>(\"legal_case_type\", (False, True, \"closed\",\"case\"))</code></li> <li>Rearrested: <code>(\"legal_rearrested\",())</code></li> <li>Pending Cases: <code>(\"legal_pending_cases\", (\"t2\",))</code></li> <li>Case Outcomes: <code>(\"legal_case_outcomes\", ())</code></li> <li>Guilty Plea Outcomes: <code>(\"legal_plea_outcomes\", (True,))</code></li> </ul>"},{"location":"grants/#cm_outreach_funcs","title":"cm_outreach_funcs","text":"<ul> <li>receiving CM: <code>(\"programs_service_tally\", (\"service_cm\",))</code></li> <li>Had CM Session in Month: <code>(\"programs_sessions\", ())</code></li> <li>CM Session Count: <code>(\"programs_session_tally\", (\"cm\",))</code></li> <li>CM Session Length: <code>(\"programs_session_length\", ())</code></li> <li>CM Session Length (Grouped): <code>(\"programs_session_length\", (\"cm\", True, True))</code></li> <li>Had Outreach Session in Month: <code>(\"programs_sessions\", (\"outreach\",))</code></li> <li>Outreach Session Count: <code>(\"programs_session_tally\", (\"outreach\",))</code></li> <li>linkage tally: <code>(\"link_tally\", (True, True, \"linked_date\",))</code></li> <li>services linked: <code>(\"link_goal_area\", (True, True, \"both\",))</code></li> </ul>"},{"location":"nice_sql_examples/","title":"Examples","text":"In\u00a0[\u00a0]: Copied! <pre>from nice_sql import Queries, JAC_IDHS\n</pre> from nice_sql import Queries, JAC_IDHS <p>Queries creates an object (q in the example below) which uses stints.classify_by_program after setting it up in your chosen timeframe</p> In\u00a0[\u00a0]: Copied! <pre>q = Queries(t1 = '2023-01-01', t2='2023-12-31', \n            print_SQL=True, clipboard=True)\n</pre> q = Queries(t1 = '2023-01-01', t2='2023-12-31',              print_SQL=True, clipboard=True)  <p>to run a pre-defined function on q, just write q.function_name . For instance, to find the number of clients rearrested in a time period you can run:</p> In\u00a0[\u00a0]: Copied! <pre>q.legal_rearrested(timeframe=True)\n</pre> q.legal_rearrested(timeframe=True) <p>it's also easy to keep using python if you want to write a SQL function on the spot. just use the format: q.query_run(f'''[standard sql function]'''). For instance, to find the number of participants active at this time:</p> In\u00a0[\u00a0]: Copied! <pre>q.query_run(f'''SELECT COUNT (distinct participant_id) \n            from stints.classify_by_program''')\n</pre> q.query_run(f'''SELECT COUNT (distinct participant_id)              from stints.classify_by_program''') <p>Grants often ask the same set of questions about clients who are active on their grant. We can write a class for a given grant which includes relevant functions. For instance:</p> In\u00a0[\u00a0]: Copied! <pre>j = JAC_IDHS(t1='2023-10-01', t2='2023-12-31', \n            print_SQL=True, clipboard=True, grant='jac')\n</pre> j = JAC_IDHS(t1='2023-10-01', t2='2023-12-31',              print_SQL=True, clipboard=True, grant='jac') <p>j inherits traits from the Queries class, so it can run the same functions as q. but it can also run functions that are only relevant to JAC grants. If you wanted to find the average number of sessions a client with jac case management had:</p> In\u00a0[\u00a0]: Copied! <pre>j.jac_cm_sessions()\n</pre> j.jac_cm_sessions() <p>Since grants usually ask the same questions, it can be annoying to rerun each query individually. So I've made a handful of pre-written reports which run the set of queries and merge them into one big copy-pastable dataframe.</p> <p>The reports can be found within nice_sql, and are a pretty easy format to replicate. To run a report, use the run_report function, and call the object's predefined report.</p> In\u00a0[\u00a0]: Copied! <pre>j.run_report(j.JAC_Smartsheet)\n</pre> j.run_report(j.JAC_Smartsheet)"},{"location":"nice_sql_examples/#examples","title":"Examples\u00b6","text":""},{"location":"nice_sql_examples/#import-statement","title":"Import Statement\u00b6","text":""},{"location":"nice_sql_examples/#queries","title":"Queries\u00b6","text":""},{"location":"nice_sql_examples/#specific-grants","title":"Specific Grants\u00b6","text":""},{"location":"tables_ref/","title":"Queries for Any Group","text":""},{"location":"tables_ref/#initializing-the-query-object","title":"Initializing the Query Object","text":"<pre><code>q = Queries(t1 = '2023-10-01', t2 = '2023-12-31', print_SQL = True, \nclipboard = True)\n</code></pre>"},{"location":"tables_ref/#demographics","title":"Demographics","text":"<p>             Bases: <code>Tables</code></p> <p>Sets up a table for a given timeframe</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <p>start date, formatted as \"YYYY-MM-DD\"</p> required <code>t2</code> <p>end date, formatted as \"YYYY-MM-DD\"</p> required <code>print_sql</code> <code>Bool</code> <p>whether to print the SQL statements when run, defaults to True</p> <code>True</code> <code>clipboard</code> <code>Bool</code> <p>whether to copy the output table to your clipboard, defaults to False</p> <code>False</code> <code>default_table</code> <p>the source table to run queries on. defaults to \"stints.classify_by_program\"</p> <code>'stints.classify_by_program'</code> Source code in <code>script\\nice_sql.py</code> <pre><code>class Queries(Tables):\n'''\n    Sets up a table for a given timeframe\n    Parameters:\n        t1: start date, formatted as \"YYYY-MM-DD\"\n        t2: end date, formatted as \"YYYY-MM-DD\"\n        print_sql (Bool): whether to print the SQL statements when run, defaults to True\n        clipboard (Bool): whether to copy the output table to your clipboard, defaults to False\n        default_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n    '''\ndef dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n        Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n            age: threshold at which a client is counted as a juvenile, defaults to 18\n            cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n        SQL Equivalent:\n            select \n                count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n            from stints.classify_by_program\n            join civicore.participants using(participant_id);'''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True:\nquery = f'''select \n                count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n                from {self.table}\n                join civicore.participants using(participant_id)'''\nelse: \nquery = f'''select \n                l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n                from {self.table} l\n                join civicore.participants using(participant_id)'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)\ndf = self.query_run(query)\nreturn(df)\ndef dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n        Returns a count of client races or genders\n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            race_gender: the category to tally, enter either \"race\" or \"gender\"\n        SQL Equivalent:\n            select race, count(distinct participant_id)\n            from stints.classify_by_program\n            join civicore.participants using(participant_id)\n            group by race;\n        '''\nquery = f'''select {race_gender}, count(distinct participant_id)\n        from {self.table}\n        join civicore.participants using(participant_id)\n        group by {race_gender}'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)  # Use self.query_modify here\ndf = self.query_run(query)\nreturn(df)\ndef dem_recent_address(self):\n'''\n        Finds the recent addresses of clients\n        SQL Equivalent:\n            with ranked_addresses as\n                (select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id \n                    ORDER BY primary_address DESC, entered_date DESC) AS rn \n                from stints.classify_by_program\n                join civicore.address a using(participant_id))\n                select * from ranked_addresses\n                where rn = 1\n                    ;\n        '''\ndef dem_recent_address(self, neighborhoods = False):\n'''\n        Finds the recent addresses of clients.\n        Parameters:\n            neighborhoods: True if using a table with neighborhoods. Defaults to False\n        '''\nif neighborhoods is False:\nquery = f'''with ranked_addresses as(select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n                    join civicore.address a using(participant_id))\n                    select * from ranked_addresses\n                    where rn = 1\n                    '''\nelse:\nquery = f'''WITH ranked_addresses AS (\n    SELECT\n        first_name,\n        last_name,\n        a.*,\n        ROW_NUMBER() OVER (\n            PARTITION BY participant_id\n            ORDER BY \n                primary_address DESC,\n                entered_date DESC,\n                CASE WHEN LOWER(neighborhood) not LIKE '%other%' THEN 1 ELSE 0 END\n        ) AS rn\n    FROM\n        (select distinct first_name, last_name, participant_id from {self.table}) s\n        JOIN tasks.neighborhoods a USING(participant_id)\n)\nSELECT participant_id, location, primary_address, entered_date, updated_date, neighborhood, rn\nFROM ranked_addresses\n'''\ndf = self.query_run(query)\nreturn(df)\ndef docs_has_formatted(self):\n'''\n        checks if clients have ISPs or Assessments and if they are formatted correctly\n        '''\nquery = f'''SELECT DISTINCT (participant_id), ASSM_ISP_formatted, has_ASSM_ISP, FCS_formatted, has_FCS,  BP_formatted, has_BP, PCL_formatted, has_PCL,  has_cdc, assess\nFROM (select * from {self.table}) cr\nLEFT JOIN( select participant_id, first_name, last_name\nfrom civicore.participants) p USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_ASSM_ISP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS ASSM_ISP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_ASSM_ISP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*'\nGROUP BY participant_id, Has_ASSM_ISP\n) assm USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_FCS_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS FCS_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*FCS.*|.*Crime.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_FCS\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*FCS.*|.*Crime.*'\nGROUP BY participant_id, has_FCS\n) fcs USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_BP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS BP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*BP.*|.*Buss.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_BP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*BP.*|.*Buss.*'\nGROUP BY participant_id, has_BP\n) bp USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_PCL_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS PCL_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_PCL\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*'\nGROUP BY participant_id, has_PCL\n) PCL USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_CDC_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS CDC_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_CDC\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*'\nGROUP BY participant_id, has_CDC\n) cdc USING (participant_id)\nleft join(\nselect participant_id,\n        COUNT(CASE\n                WHEN d.document_type = 'Assessments' THEN 1 ELSE NULL END) as assess\n from documents.unfiltered d\n group by participant_id) asseses USING (participant_id);'''\ndf = self.query_run(query)\nreturn df\ndef grant_tally(self, start_end = None):\n'''\n        counts how many clients are on a grant\n        Parameters\n            start_end: \"start_date\" returns clients who started in timeframe, \"end_date\" returns clients who ended\n        '''\nquery = f'''select grant_type, count(distinct participant_id) from {self.table} group by grant_type'''\nif start_end == \"start_date\":\nquery = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or active_date between {self.q_t1} and {self.q_t2}''')\nelif start_end == \"end_date\":\nquery = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or closed_date between {self.q_t1} and {self.q_t2}''')\ndf = self.query_run(query)\nreturn df\ndef incident_tally(self):\n'''\n        counts incidents in timeframe\n        '''\nquery = f'''SELECT count(case when how_hear regexp '.*CPIC.*' then incident_id else null end) as CPIC,\n\tcount(case when how_hear not regexp '.*CPIC.*' then incident_id else null end) as non_CPIC\nFROM civicore.critical_incidents\nwhere (date_incident between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\ndef legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n        SQL Equivalent:\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\nquery = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\nif pending is True:\nquery = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\ndf = self.query_run(query)\nreturn df\ndef legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n        SQL Equivalent:\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True: \nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\nelse:\nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\ndf = self.query_run(query)\nreturn df\ndef legal_program_involvement(self, program_timeframe = False):\n'''\n        returns linkage and case session tallies for clients with cases ended in a timeframe\n        Parameters:\n            program_timeframe: True only counts linkages/case sessions in timeframe, defaults to False\n        SQL Equivalent:\n            with outcomes as (select participant_id, charge, case_type,\n                case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n                (select * from \n                    (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                    GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)) d),\n            links as (select participant_id,\n                count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n                count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n                from civicore.linkages\n                where hub_initiated = \"yes\"\n                group by participant_id),\n            sessions as (select participant_id,\n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n            group by participant_id)\n            select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n            left join links l on o.participant_id = l.participant_id\n            left join sessions s on o.participant_id = s.participant_id;\n        '''\nif program_timeframe is True: \nquery = f'''with outcomes as (select participant_id, charge, case_type,\n        case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n        group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)) d),\n    links as (select participant_id,\n    count(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\n    count(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\n    sessions as (select participant_id,\n            COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n        COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id)\n    where (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\n    group by participant_id)\n    select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n    left join links l on o.participant_id = l.participant_id\n    left join sessions s on o.participant_id = s.participant_id'''\nelse:\nquery = f'''with outcomes as (select participant_id, charge, case_type,\n        case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n        group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)) d),\n    links as (select participant_id,\n    count(case when linked_date is not null then 1 else null end) as link_ct,\n    count(case when start_date is not null then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\n    sessions as (select participant_id,\n            COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n        COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id)\n    where (session_date is not null) and session_casenote = \"Casenote\"\n    group by participant_id)\n    select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n    left join links l on o.participant_id = l.participant_id\n    left join sessions s on o.participant_id = s.participant_id'''\ndf = self.query_run(query)\ndf = df.fillna(0)\ndf['order'] = df.groupby('participant_id').cumcount() + 1\npivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\npivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\nmax_cases = df['order'].max()\ncase_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\ncase_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\nother_columns = [col for col in pivoted_df.columns if col not in case_columns]\npivoted_df = pivoted_df[case_columns + other_columns]\npivoted_df = pivoted_df.reset_index()\nif self.clipboard is True:\npivoted_df.to_clipboard()\nreturn pivoted_df\ndef legal_fel_reduction(self, timeframe = True):\n'''\n        Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            select felony, count(felony) FROM \n                (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                    ELSE 'remained' \n                END AS felony from\n                    (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                            CASE\n                                WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                                ELSE 'Not Lower'\n                            END AS rank_comparison from civicore.legal lt \n                            join stints.classify_by_program using(participant_id) \n                            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                        GROUP BY participant_id) j\n                    ) k \n                group by felony;\n        '''\nif timeframe is True: \nquery = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n            GROUP BY participant_id) j) k group by felony;'''\nelse:\nquery = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL) h \n            GROUP BY participant_id) j) k group by felony;'''\ndf = self.query_run(query)\nreturn df\ndef legal_case_outcomes(self,  timeframe = True):\n'''\n        returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            with ranked_df as \n            (select * from \n                (SELECT participant_id, case_outcome, \n                GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n                GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                    (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)),\n            plea_concat as \n                (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n                else case_outcome end as case_outcome\n            from (select case_outcome, sentence from ranked_df d1\n            LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n            WHERE d2.ranking IS NULL)h)\n            select case_outcome, count(case_outcome) from plea_concat\n            group by case_outcome\n        '''\nif timeframe is True: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome\n        '''\nelse: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id)) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome'''\ndf = self.query_run(query)\nreturn df    \ndef legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n        SQL Equivalent:\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n        '''\nif timeframe is False:\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nrelevant_date = \"arrest_date\"\nelse:\nrelevant_date = \"case_outcome_date\"\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Plead Guilty' then 4\nwhen case_status_current = 'Found Guilty' then 5\nelse 6\nend asc'''\ndf = self.query_run(query)\nreturn df\ndef legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \nif timeframe is True:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\nelse:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\ndf = self.query_run(query)\nreturn df\ndef legal_case_type(self, timeframe = False, first_charge = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            first_charge(Bool): if true, only returns earliest case(s) in CiviCore. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n        SQL Equivalent:\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\nif case_client == \"case\":\ncase_client = \"case_id\"\nif case_client ==\"client\":\ncase_client = \"participant_id\"     \nif first_charge is True:\nquery = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\nelse: \nquery = f'''\n        WITH mlegal AS (SELECT *\n        FROM (\n            SELECT DISTINCT participant_id, active_date, closed_date\n            FROM {self.table}\n        ) k\n        JOIN civicore.legal l USING (participant_id)\n        JOIN tasks.last_close USING (participant_id)\n        WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n    )\n    select case_type,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n    from mlegal\n    group by case_type\n    ORDER BY case when case_type = 'property' then 1\n    when case_type = 'gun' then 2\n    when case_type = 'battery' then 3\n    when case_type = 'drug' then 4\n    when case_type = 'attempted murder' then 5\n    when case_type = 'murder' then 6\n    when case_type = 'other' then 7\n    else 8\n    end asc\n    '''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nopened_closed = \"arrest_date\"\nquery = self.query_modify(str(query), f'''where (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\nelse:\nopened_closed = \"case_outcome_date\"\nquery = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \ndf = self.query_run(query)\nif percentage is True:\ndf = self.percentage_convert(df, replace= False)\nreturn df    \ndef legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n        SQL Equivalent:\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\nquery = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\ndf = self.query_run(query)\nreturn df\ndef legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n        SQL Equivalent:\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\nif t1_t2 == \"t1\": \nt1_t2 = self.q_t1\nelse:\nt1_t2 = self.q_t2\nif also_ended == False:\nquery = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\ndf = self.query_run(query)\nreturn df\nelse:\nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\ndf = self.query_run(query)\nreturn df\ndef legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n        SQL Equivalent:\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\nif timeframe is True:\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \ndf = self.query_run(query)\nreturn df\ndef link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n        Returns the number of clients with at least one linkage\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n        SQL Equivalent:\n            select count(distinct participant_id) from \n                (select participant_id from stints.classify_by_program) x \n            join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n        '''\nquery = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\nif hub_initiated is False and timeframe is False:\ndf = self.query_run(query)\nreturn df\nif started_linked.lower() == \"both\":\nif hub_initiated is False:\nquery = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\nif hub_initiated is True and timeframe is False:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\nelse:\nif hub_initiated is False and timeframe is True:\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif hub_initiated is True and timeframe is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\ndf = self.query_run(query)\nreturn df\ndef link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n        SQL Equivalent:\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\nif cutoff_date == \"t1\":\ncutoff_date = self.t1\nif link_type.lower() == \"education\":\ninequality_sign = '&lt;'\nif link_type.lower() == \"employment\":\ninequality_sign = '&gt;'\nlink_type = f\"'{link_type}'\"\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nquery = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\nif hub_initiated == True:\nquery = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\nif first_n_months is not None:\nquery = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\ndf = self.query_run(query)\nreturn df\ndef link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n        SQL Equivalent:\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\nquery = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\nif timeframe == True:\nif started_linked == \"linked_date\" or started_linked == \"start_date\":\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif started_linked == \"both\" or started_linked == \"Both\":\nquery = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated == True:\nquery = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\nif timeframe == False and hub_initiated == True:\nquery = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\ndf = self.query_run(query)\nreturn df\ndef mediation_tally(self, followup = False):\n'''\n        counts number of mediations in timeframe\n        Parameters\n            followup (Bool): if True, returns followup mediation tally. Defaults to False\n        '''\nif followup == False:\nquery = f'''select outcome_mediation, count(outcome_mediation) from civicore.mediations\nwhere (date_start_mediation between{self.q_t1} and {self.q_t2})\ngroup by outcome_mediation'''\nelse:\nquery = f'''select outcome_mediation, count(outcome_mediation) from civicore.mediation_followup\n    where (date_session between{self.q_t1} and {self.q_t2})\n    group by outcome_mediation'''\ndf = self.query_run(query)\nreturn df\ndef mediation_time_spent(self):\n'''\n        sums the number of hours spent on mediations\n        '''\nquery = f'''select sum(hours_spent_mediation) from civicore.mediations where (date_conflict between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\ndef programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n        SQL Equivalent:\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n        '''\nquery = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\ndf = self.query_run(query)\nreturn df\ndef programs_service_tally(self, service_column):\n'''\n        Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n        Parameters:\n            Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n        SQL Equivalent: \n            select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n        '''\nif service_column.lower() == \"outreach\":\nquery = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\nelse:\nquery = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\ndf = self.query_run(query)\nreturn df\ndef outreach_tally(self):\n'''\n        counts clients receiving outreach\n        '''\nquery = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\ndf = self.query_run(query)\nreturn df\ndef programs_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n        Counts clients who have at least one recorded session with a case manager or outreach worker\n        Parameters:\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n        SQL Equivalent: \n            select count(distinct participant_id) from stints.classify_by_program \n            join civicore.case_sessions using(participant_id) \n            where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\ndf = self.query_run(query)\nreturn df\ndef programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n        SQL Equivalent:\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\ndf = self.query_run(query)\nreturn df\ndef programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n        SQL Equivalent:\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\nif demographic == \"age\" and self.joined_participants == False:\nquery = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\nelse:\nquery = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\nif self.joined_participants == False and demographic != \"age\":\nquery = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\ndf = self.query_run(query)\nif percentages == True:\ndf = self.percentage_convert(df)\nreturn df\ndef programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n        Finds the length of case management or outreach sessions\n        Parameters:\n            cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n            grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n        SQL Equivalent:\n            select \n                avg(hours) * 60 as overall,\n                avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\nif cm_outreach == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nif grouped is False:\nquery = f'''select \n            avg(hours) * 60 as overall,\n         avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\nif grouped is True:\nif timeframe is True:  \nquery = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\nelse: \nquery = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_casenote = {cm_outreach})\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\ndf = self.query_run(query)\nreturn df\ndef programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n        SQL Equivalent:\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\nquery = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.dem_age","title":"dem_age","text":"<pre><code>dem_age(new_clients=False, tally=True, age=18, cutoff_date='active_date')\n</code></pre> <p>Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults </p> <p>Parameters:</p> Name Type Description Default <code>new_clients</code> <code>Bool</code> <p>if true, only counts clients who began between t1 and t2. defaults to False</p> <code>False</code> <code>tally</code> <code>Bool</code> <p>if true, returns a count of juv/adults, if false, returns a list. defaults to True</p> <code>True</code> <code>age</code> <p>threshold at which a client is counted as a juvenile, defaults to 18</p> <code>18</code> <code>cutoff_date</code> <p>time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format</p> <code>'active_date'</code> <p>SQL Equivalent:</p> <pre><code>select \n    count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n    count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\nfrom stints.classify_by_program\njoin civicore.participants using(participant_id);\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>def dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n    Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n    Parameters:\n        new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n        tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n        age: threshold at which a client is counted as a juvenile, defaults to 18\n        cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n    SQL Equivalent:\n        select \n            count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n            count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n        from stints.classify_by_program\n        join civicore.participants using(participant_id);'''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True:\nquery = f'''select \n            count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n            count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n            from {self.table}\n            join civicore.participants using(participant_id)'''\nelse: \nquery = f'''select \n            l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n            from {self.table} l\n            join civicore.participants using(participant_id)'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)\ndf = self.query_run(query)\nreturn(df)\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.dem_race_gender","title":"dem_race_gender","text":"<pre><code>dem_race_gender(new_clients=False, race_gender=None)\n</code></pre> <p>Returns a count of client races or genders</p> <p>Parameters:</p> Name Type Description Default <code>new_clients</code> <code>Bool</code> <p>if true, only counts clients who began between t1 and t2. defaults to False</p> <code>False</code> <code>race_gender</code> <p>the category to tally, enter either \"race\" or \"gender\"</p> <code>None</code> <p>SQL Equivalent:</p> <pre><code>select race, count(distinct participant_id)\nfrom stints.classify_by_program\njoin civicore.participants using(participant_id)\ngroup by race;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>def dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n    Returns a count of client races or genders\n    Parameters:\n        new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n        race_gender: the category to tally, enter either \"race\" or \"gender\"\n    SQL Equivalent:\n        select race, count(distinct participant_id)\n        from stints.classify_by_program\n        join civicore.participants using(participant_id)\n        group by race;\n    '''\nquery = f'''select {race_gender}, count(distinct participant_id)\n    from {self.table}\n    join civicore.participants using(participant_id)\n    group by {race_gender}'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)  # Use self.query_modify here\ndf = self.query_run(query)\nreturn(df)\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.dem_recent_address","title":"dem_recent_address","text":"<pre><code>dem_recent_address(neighborhoods=False)\n</code></pre> <p>Finds the recent addresses of clients. Parameters:     neighborhoods: True if using a table with neighborhoods. Defaults to False</p> Source code in <code>script\\nice_sql.py</code> <pre><code>    def dem_recent_address(self, neighborhoods = False):\n'''\n        Finds the recent addresses of clients.\n        Parameters:\n            neighborhoods: True if using a table with neighborhoods. Defaults to False\n        '''\nif neighborhoods is False:\nquery = f'''with ranked_addresses as(select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n                    join civicore.address a using(participant_id))\n                    select * from ranked_addresses\n                    where rn = 1\n                    '''\nelse:\nquery = f'''WITH ranked_addresses AS (\n    SELECT\n        first_name,\n        last_name,\n        a.*,\n        ROW_NUMBER() OVER (\n            PARTITION BY participant_id\n            ORDER BY \n                primary_address DESC,\n                entered_date DESC,\n                CASE WHEN LOWER(neighborhood) not LIKE '%other%' THEN 1 ELSE 0 END\n        ) AS rn\n    FROM\n        (select distinct first_name, last_name, participant_id from {self.table}) s\n        JOIN tasks.neighborhoods a USING(participant_id)\n)\nSELECT participant_id, location, primary_address, entered_date, updated_date, neighborhood, rn\nFROM ranked_addresses\n'''\ndf = self.query_run(query)\nreturn(df)\n</code></pre>"},{"location":"tables_ref/#legal","title":"Legal","text":"<p>             Bases: <code>Tables</code></p> <p>Sets up a table for a given timeframe</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <p>start date, formatted as \"YYYY-MM-DD\"</p> required <code>t2</code> <p>end date, formatted as \"YYYY-MM-DD\"</p> required <code>print_sql</code> <code>Bool</code> <p>whether to print the SQL statements when run, defaults to True</p> <code>True</code> <code>clipboard</code> <code>Bool</code> <p>whether to copy the output table to your clipboard, defaults to False</p> <code>False</code> <code>default_table</code> <p>the source table to run queries on. defaults to \"stints.classify_by_program\"</p> <code>'stints.classify_by_program'</code> Source code in <code>script\\nice_sql.py</code> <pre><code>class Queries(Tables):\n'''\n    Sets up a table for a given timeframe\n    Parameters:\n        t1: start date, formatted as \"YYYY-MM-DD\"\n        t2: end date, formatted as \"YYYY-MM-DD\"\n        print_sql (Bool): whether to print the SQL statements when run, defaults to True\n        clipboard (Bool): whether to copy the output table to your clipboard, defaults to False\n        default_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n    '''\ndef dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n        Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n            age: threshold at which a client is counted as a juvenile, defaults to 18\n            cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n        SQL Equivalent:\n            select \n                count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n            from stints.classify_by_program\n            join civicore.participants using(participant_id);'''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True:\nquery = f'''select \n                count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n                from {self.table}\n                join civicore.participants using(participant_id)'''\nelse: \nquery = f'''select \n                l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n                from {self.table} l\n                join civicore.participants using(participant_id)'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)\ndf = self.query_run(query)\nreturn(df)\ndef dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n        Returns a count of client races or genders\n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            race_gender: the category to tally, enter either \"race\" or \"gender\"\n        SQL Equivalent:\n            select race, count(distinct participant_id)\n            from stints.classify_by_program\n            join civicore.participants using(participant_id)\n            group by race;\n        '''\nquery = f'''select {race_gender}, count(distinct participant_id)\n        from {self.table}\n        join civicore.participants using(participant_id)\n        group by {race_gender}'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)  # Use self.query_modify here\ndf = self.query_run(query)\nreturn(df)\ndef dem_recent_address(self):\n'''\n        Finds the recent addresses of clients\n        SQL Equivalent:\n            with ranked_addresses as\n                (select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id \n                    ORDER BY primary_address DESC, entered_date DESC) AS rn \n                from stints.classify_by_program\n                join civicore.address a using(participant_id))\n                select * from ranked_addresses\n                where rn = 1\n                    ;\n        '''\ndef dem_recent_address(self, neighborhoods = False):\n'''\n        Finds the recent addresses of clients.\n        Parameters:\n            neighborhoods: True if using a table with neighborhoods. Defaults to False\n        '''\nif neighborhoods is False:\nquery = f'''with ranked_addresses as(select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n                    join civicore.address a using(participant_id))\n                    select * from ranked_addresses\n                    where rn = 1\n                    '''\nelse:\nquery = f'''WITH ranked_addresses AS (\n    SELECT\n        first_name,\n        last_name,\n        a.*,\n        ROW_NUMBER() OVER (\n            PARTITION BY participant_id\n            ORDER BY \n                primary_address DESC,\n                entered_date DESC,\n                CASE WHEN LOWER(neighborhood) not LIKE '%other%' THEN 1 ELSE 0 END\n        ) AS rn\n    FROM\n        (select distinct first_name, last_name, participant_id from {self.table}) s\n        JOIN tasks.neighborhoods a USING(participant_id)\n)\nSELECT participant_id, location, primary_address, entered_date, updated_date, neighborhood, rn\nFROM ranked_addresses\n'''\ndf = self.query_run(query)\nreturn(df)\ndef docs_has_formatted(self):\n'''\n        checks if clients have ISPs or Assessments and if they are formatted correctly\n        '''\nquery = f'''SELECT DISTINCT (participant_id), ASSM_ISP_formatted, has_ASSM_ISP, FCS_formatted, has_FCS,  BP_formatted, has_BP, PCL_formatted, has_PCL,  has_cdc, assess\nFROM (select * from {self.table}) cr\nLEFT JOIN( select participant_id, first_name, last_name\nfrom civicore.participants) p USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_ASSM_ISP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS ASSM_ISP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_ASSM_ISP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*'\nGROUP BY participant_id, Has_ASSM_ISP\n) assm USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_FCS_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS FCS_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*FCS.*|.*Crime.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_FCS\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*FCS.*|.*Crime.*'\nGROUP BY participant_id, has_FCS\n) fcs USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_BP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS BP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*BP.*|.*Buss.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_BP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*BP.*|.*Buss.*'\nGROUP BY participant_id, has_BP\n) bp USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_PCL_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS PCL_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_PCL\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*'\nGROUP BY participant_id, has_PCL\n) PCL USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_CDC_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS CDC_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_CDC\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*'\nGROUP BY participant_id, has_CDC\n) cdc USING (participant_id)\nleft join(\nselect participant_id,\n        COUNT(CASE\n                WHEN d.document_type = 'Assessments' THEN 1 ELSE NULL END) as assess\n from documents.unfiltered d\n group by participant_id) asseses USING (participant_id);'''\ndf = self.query_run(query)\nreturn df\ndef grant_tally(self, start_end = None):\n'''\n        counts how many clients are on a grant\n        Parameters\n            start_end: \"start_date\" returns clients who started in timeframe, \"end_date\" returns clients who ended\n        '''\nquery = f'''select grant_type, count(distinct participant_id) from {self.table} group by grant_type'''\nif start_end == \"start_date\":\nquery = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or active_date between {self.q_t1} and {self.q_t2}''')\nelif start_end == \"end_date\":\nquery = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or closed_date between {self.q_t1} and {self.q_t2}''')\ndf = self.query_run(query)\nreturn df\ndef incident_tally(self):\n'''\n        counts incidents in timeframe\n        '''\nquery = f'''SELECT count(case when how_hear regexp '.*CPIC.*' then incident_id else null end) as CPIC,\n\tcount(case when how_hear not regexp '.*CPIC.*' then incident_id else null end) as non_CPIC\nFROM civicore.critical_incidents\nwhere (date_incident between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\ndef legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n        SQL Equivalent:\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\nquery = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\nif pending is True:\nquery = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\ndf = self.query_run(query)\nreturn df\ndef legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n        SQL Equivalent:\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True: \nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\nelse:\nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\ndf = self.query_run(query)\nreturn df\ndef legal_program_involvement(self, program_timeframe = False):\n'''\n        returns linkage and case session tallies for clients with cases ended in a timeframe\n        Parameters:\n            program_timeframe: True only counts linkages/case sessions in timeframe, defaults to False\n        SQL Equivalent:\n            with outcomes as (select participant_id, charge, case_type,\n                case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n                (select * from \n                    (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                    GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)) d),\n            links as (select participant_id,\n                count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n                count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n                from civicore.linkages\n                where hub_initiated = \"yes\"\n                group by participant_id),\n            sessions as (select participant_id,\n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n            group by participant_id)\n            select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n            left join links l on o.participant_id = l.participant_id\n            left join sessions s on o.participant_id = s.participant_id;\n        '''\nif program_timeframe is True: \nquery = f'''with outcomes as (select participant_id, charge, case_type,\n        case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n        group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)) d),\n    links as (select participant_id,\n    count(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\n    count(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\n    sessions as (select participant_id,\n            COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n        COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id)\n    where (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\n    group by participant_id)\n    select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n    left join links l on o.participant_id = l.participant_id\n    left join sessions s on o.participant_id = s.participant_id'''\nelse:\nquery = f'''with outcomes as (select participant_id, charge, case_type,\n        case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n        group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)) d),\n    links as (select participant_id,\n    count(case when linked_date is not null then 1 else null end) as link_ct,\n    count(case when start_date is not null then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\n    sessions as (select participant_id,\n            COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n        COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id)\n    where (session_date is not null) and session_casenote = \"Casenote\"\n    group by participant_id)\n    select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n    left join links l on o.participant_id = l.participant_id\n    left join sessions s on o.participant_id = s.participant_id'''\ndf = self.query_run(query)\ndf = df.fillna(0)\ndf['order'] = df.groupby('participant_id').cumcount() + 1\npivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\npivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\nmax_cases = df['order'].max()\ncase_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\ncase_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\nother_columns = [col for col in pivoted_df.columns if col not in case_columns]\npivoted_df = pivoted_df[case_columns + other_columns]\npivoted_df = pivoted_df.reset_index()\nif self.clipboard is True:\npivoted_df.to_clipboard()\nreturn pivoted_df\ndef legal_fel_reduction(self, timeframe = True):\n'''\n        Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            select felony, count(felony) FROM \n                (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                    ELSE 'remained' \n                END AS felony from\n                    (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                            CASE\n                                WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                                ELSE 'Not Lower'\n                            END AS rank_comparison from civicore.legal lt \n                            join stints.classify_by_program using(participant_id) \n                            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                        GROUP BY participant_id) j\n                    ) k \n                group by felony;\n        '''\nif timeframe is True: \nquery = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n            GROUP BY participant_id) j) k group by felony;'''\nelse:\nquery = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL) h \n            GROUP BY participant_id) j) k group by felony;'''\ndf = self.query_run(query)\nreturn df\ndef legal_case_outcomes(self,  timeframe = True):\n'''\n        returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            with ranked_df as \n            (select * from \n                (SELECT participant_id, case_outcome, \n                GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n                GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                    (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)),\n            plea_concat as \n                (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n                else case_outcome end as case_outcome\n            from (select case_outcome, sentence from ranked_df d1\n            LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n            WHERE d2.ranking IS NULL)h)\n            select case_outcome, count(case_outcome) from plea_concat\n            group by case_outcome\n        '''\nif timeframe is True: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome\n        '''\nelse: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id)) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome'''\ndf = self.query_run(query)\nreturn df    \ndef legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n        SQL Equivalent:\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n        '''\nif timeframe is False:\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nrelevant_date = \"arrest_date\"\nelse:\nrelevant_date = \"case_outcome_date\"\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Plead Guilty' then 4\nwhen case_status_current = 'Found Guilty' then 5\nelse 6\nend asc'''\ndf = self.query_run(query)\nreturn df\ndef legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \nif timeframe is True:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\nelse:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\ndf = self.query_run(query)\nreturn df\ndef legal_case_type(self, timeframe = False, first_charge = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            first_charge(Bool): if true, only returns earliest case(s) in CiviCore. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n        SQL Equivalent:\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\nif case_client == \"case\":\ncase_client = \"case_id\"\nif case_client ==\"client\":\ncase_client = \"participant_id\"     \nif first_charge is True:\nquery = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\nelse: \nquery = f'''\n        WITH mlegal AS (SELECT *\n        FROM (\n            SELECT DISTINCT participant_id, active_date, closed_date\n            FROM {self.table}\n        ) k\n        JOIN civicore.legal l USING (participant_id)\n        JOIN tasks.last_close USING (participant_id)\n        WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n    )\n    select case_type,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n    from mlegal\n    group by case_type\n    ORDER BY case when case_type = 'property' then 1\n    when case_type = 'gun' then 2\n    when case_type = 'battery' then 3\n    when case_type = 'drug' then 4\n    when case_type = 'attempted murder' then 5\n    when case_type = 'murder' then 6\n    when case_type = 'other' then 7\n    else 8\n    end asc\n    '''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nopened_closed = \"arrest_date\"\nquery = self.query_modify(str(query), f'''where (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\nelse:\nopened_closed = \"case_outcome_date\"\nquery = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \ndf = self.query_run(query)\nif percentage is True:\ndf = self.percentage_convert(df, replace= False)\nreturn df    \ndef legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n        SQL Equivalent:\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\nquery = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\ndf = self.query_run(query)\nreturn df\ndef legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n        SQL Equivalent:\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\nif t1_t2 == \"t1\": \nt1_t2 = self.q_t1\nelse:\nt1_t2 = self.q_t2\nif also_ended == False:\nquery = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\ndf = self.query_run(query)\nreturn df\nelse:\nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\ndf = self.query_run(query)\nreturn df\ndef legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n        SQL Equivalent:\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\nif timeframe is True:\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \ndf = self.query_run(query)\nreturn df\ndef link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n        Returns the number of clients with at least one linkage\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n        SQL Equivalent:\n            select count(distinct participant_id) from \n                (select participant_id from stints.classify_by_program) x \n            join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n        '''\nquery = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\nif hub_initiated is False and timeframe is False:\ndf = self.query_run(query)\nreturn df\nif started_linked.lower() == \"both\":\nif hub_initiated is False:\nquery = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\nif hub_initiated is True and timeframe is False:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\nelse:\nif hub_initiated is False and timeframe is True:\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif hub_initiated is True and timeframe is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\ndf = self.query_run(query)\nreturn df\ndef link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n        SQL Equivalent:\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\nif cutoff_date == \"t1\":\ncutoff_date = self.t1\nif link_type.lower() == \"education\":\ninequality_sign = '&lt;'\nif link_type.lower() == \"employment\":\ninequality_sign = '&gt;'\nlink_type = f\"'{link_type}'\"\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nquery = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\nif hub_initiated == True:\nquery = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\nif first_n_months is not None:\nquery = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\ndf = self.query_run(query)\nreturn df\ndef link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n        SQL Equivalent:\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\nquery = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\nif timeframe == True:\nif started_linked == \"linked_date\" or started_linked == \"start_date\":\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif started_linked == \"both\" or started_linked == \"Both\":\nquery = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated == True:\nquery = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\nif timeframe == False and hub_initiated == True:\nquery = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\ndf = self.query_run(query)\nreturn df\ndef mediation_tally(self, followup = False):\n'''\n        counts number of mediations in timeframe\n        Parameters\n            followup (Bool): if True, returns followup mediation tally. Defaults to False\n        '''\nif followup == False:\nquery = f'''select outcome_mediation, count(outcome_mediation) from civicore.mediations\nwhere (date_start_mediation between{self.q_t1} and {self.q_t2})\ngroup by outcome_mediation'''\nelse:\nquery = f'''select outcome_mediation, count(outcome_mediation) from civicore.mediation_followup\n    where (date_session between{self.q_t1} and {self.q_t2})\n    group by outcome_mediation'''\ndf = self.query_run(query)\nreturn df\ndef mediation_time_spent(self):\n'''\n        sums the number of hours spent on mediations\n        '''\nquery = f'''select sum(hours_spent_mediation) from civicore.mediations where (date_conflict between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\ndef programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n        SQL Equivalent:\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n        '''\nquery = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\ndf = self.query_run(query)\nreturn df\ndef programs_service_tally(self, service_column):\n'''\n        Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n        Parameters:\n            Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n        SQL Equivalent: \n            select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n        '''\nif service_column.lower() == \"outreach\":\nquery = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\nelse:\nquery = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\ndf = self.query_run(query)\nreturn df\ndef outreach_tally(self):\n'''\n        counts clients receiving outreach\n        '''\nquery = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\ndf = self.query_run(query)\nreturn df\ndef programs_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n        Counts clients who have at least one recorded session with a case manager or outreach worker\n        Parameters:\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n        SQL Equivalent: \n            select count(distinct participant_id) from stints.classify_by_program \n            join civicore.case_sessions using(participant_id) \n            where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\ndf = self.query_run(query)\nreturn df\ndef programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n        SQL Equivalent:\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\ndf = self.query_run(query)\nreturn df\ndef programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n        SQL Equivalent:\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\nif demographic == \"age\" and self.joined_participants == False:\nquery = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\nelse:\nquery = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\nif self.joined_participants == False and demographic != \"age\":\nquery = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\ndf = self.query_run(query)\nif percentages == True:\ndf = self.percentage_convert(df)\nreturn df\ndef programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n        Finds the length of case management or outreach sessions\n        Parameters:\n            cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n            grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n        SQL Equivalent:\n            select \n                avg(hours) * 60 as overall,\n                avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\nif cm_outreach == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nif grouped is False:\nquery = f'''select \n            avg(hours) * 60 as overall,\n         avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\nif grouped is True:\nif timeframe is True:  \nquery = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\nelse: \nquery = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_casenote = {cm_outreach})\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\ndf = self.query_run(query)\nreturn df\ndef programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n        SQL Equivalent:\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\nquery = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_case_outcomes","title":"<code>legal_case_outcomes(timeframe=True)</code>","text":"<p>returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)</p> <p>Parameters:</p> Name Type Description Default <code>timeframe</code> <code>Bool</code> <p>if true, only looks at cases between T1 and T2. Defaults to True</p> <code>True</code> <p>SQL Equivalent:</p> <pre><code>with ranked_df as \n(select * from \n    (SELECT participant_id, case_outcome, \n    GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n        (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n    group by participant_id, case_outcome) d1\nleft join tasks.highest_case using(case_outcome)),\nplea_concat as \n    (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n    else case_outcome end as case_outcome\nfrom (select case_outcome, sentence from ranked_df d1\nLEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\nWHERE d2.ranking IS NULL)h)\nselect case_outcome, count(case_outcome) from plea_concat\ngroup by case_outcome\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>def legal_case_outcomes(self,  timeframe = True):\n'''\n    returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n    Parameters:\n        timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n    SQL Equivalent:\n        with ranked_df as \n        (select * from \n            (SELECT participant_id, case_outcome, \n            GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n            GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n            group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)),\n        plea_concat as \n            (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n            else case_outcome end as case_outcome\n        from (select case_outcome, sentence from ranked_df d1\n        LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n        WHERE d2.ranking IS NULL)h)\n        select case_outcome, count(case_outcome) from plea_concat\n        group by case_outcome\n    '''\nif timeframe is True: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1\nleft join tasks.highest_case using(case_outcome)), \nplea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\nfrom (select case_outcome, sentence from ranked_df d1\nLEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\nWHERE\n    d2.ranking IS NULL)h)\nselect case_outcome, count(case_outcome) from plea_concat\ngroup by case_outcome\n    '''\nelse: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id)) r\ngroup by participant_id, case_outcome) d1\nleft join tasks.highest_case using(case_outcome)), \nplea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\nfrom (select case_outcome, sentence from ranked_df d1\nLEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\nWHERE\n    d2.ranking IS NULL)h)\nselect case_outcome, count(case_outcome) from plea_concat\ngroup by case_outcome'''\ndf = self.query_run(query)\nreturn df    \n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_case_statuses","title":"<code>legal_case_statuses(timeframe=False, opened_closed='closed')</code>","text":"<p>returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2</p> <p>Parameters:</p> Name Type Description Default <code>timeframe(Bool)</code> <p>if true, only looks at cases between T1 and T2. Defaults to False</p> required <code>opened_closed</code> <p>only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened</p> <code>'closed'</code> <p>SQL Equivalent:</p> <pre><code>with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\n    COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n    COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL\nselect case_outcome,\n    COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n    COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n        SQL Equivalent:\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n        '''\nif timeframe is False:\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nrelevant_date = \"arrest_date\"\nelse:\nrelevant_date = \"case_outcome_date\"\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Plead Guilty' then 4\nwhen case_status_current = 'Found Guilty' then 5\nelse 6\nend asc'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_case_type","title":"<code>legal_case_type(timeframe=False, first_charge=False, opened_closed='opened', percentage=False, case_client='case')</code>","text":"<p>Returns counts of cases by type (gun, drug, etc) </p> <p>Parameters:</p> Name Type Description Default <code>timeframe</code> <code>Bool</code> <p>if true, only looks at cases between T1 and T2. Defaults to False</p> <code>False</code> <code>first_charge(Bool)</code> <p>if true, only returns earliest case(s) in CiviCore. Defaults to False</p> required <code>opened_closed</code> <p>only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened</p> <code>'opened'</code> <code>percentage</code> <code>Bool</code> <p>if True, returns a percentage breakdown. Defaults to False</p> <code>False</code> <code>case_client</code> <p>\"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"</p> <code>'case'</code> <p>SQL Equivalent:</p> <pre><code>WITH mleg AS (\n    SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM participants.hd\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.*\n    FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def legal_case_type(self, timeframe = False, first_charge = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            first_charge(Bool): if true, only returns earliest case(s) in CiviCore. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n        SQL Equivalent:\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\nif case_client == \"case\":\ncase_client = \"case_id\"\nif case_client ==\"client\":\ncase_client = \"participant_id\"     \nif first_charge is True:\nquery = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\nelse: \nquery = f'''\n        WITH mlegal AS (SELECT *\n        FROM (\n            SELECT DISTINCT participant_id, active_date, closed_date\n            FROM {self.table}\n        ) k\n        JOIN civicore.legal l USING (participant_id)\n        JOIN tasks.last_close USING (participant_id)\n        WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n    )\n    select case_type,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n    from mlegal\n    group by case_type\n    ORDER BY case when case_type = 'property' then 1\n    when case_type = 'gun' then 2\n    when case_type = 'battery' then 3\n    when case_type = 'drug' then 4\n    when case_type = 'attempted murder' then 5\n    when case_type = 'murder' then 6\n    when case_type = 'other' then 7\n    else 8\n    end asc\n    '''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nopened_closed = \"arrest_date\"\nquery = self.query_modify(str(query), f'''where (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\nelse:\nopened_closed = \"case_outcome_date\"\nquery = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \ndf = self.query_run(query)\nif percentage is True:\ndf = self.percentage_convert(df, replace= False)\nreturn df    \n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_fel_reduction","title":"<code>legal_fel_reduction(timeframe=True)</code>","text":"<p>Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table</p> <p>Parameters:</p> Name Type Description Default <code>timeframe(Bool)</code> <p>if true, only looks at cases between T1 and T2. Defaults to True</p> required <p>SQL Equivalent:</p> <pre><code>select felony, count(felony) FROM \n    (select CASE \n        WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n        ELSE 'remained' \n    END AS felony from\n        (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                CASE\n                    WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                    ELSE 'Not Lower'\n                END AS rank_comparison from civicore.legal lt \n                join stints.classify_by_program using(participant_id) \n                JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n            GROUP BY participant_id) j\n        ) k \n    group by felony;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>def legal_fel_reduction(self, timeframe = True):\n'''\n    Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n    Parameters:\n        timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n    SQL Equivalent:\n        select felony, count(felony) FROM \n            (select CASE \n                WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                ELSE 'remained' \n            END AS felony from\n                (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                    FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                        CASE\n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                            ELSE 'Not Lower'\n                        END AS rank_comparison from civicore.legal lt \n                        join stints.classify_by_program using(participant_id) \n                        JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                        JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                        where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                    GROUP BY participant_id) j\n                ) k \n            group by felony;\n    '''\nif timeframe is True: \nquery = f'''select felony, count(felony) FROM \n(select CASE \n                WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n        ELSE 'remained' END AS felony  \n        from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n        CASE         \n                        WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                        ELSE 'Not Lower'     \n            END AS rank_comparison from civicore.legal lt \n                join {self.table} using(participant_id) \n        JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n        JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n        where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n        GROUP BY participant_id) j) k group by felony;'''\nelse:\nquery = f'''select felony, count(felony) FROM \n(select CASE \n                WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n        ELSE 'remained' END AS felony  \n        from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n        CASE         \n                        WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                        ELSE 'Not Lower'     \n            END AS rank_comparison from civicore.legal lt \n                join {self.table} using(participant_id) \n        JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n        JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n        where class_after_plea_trial IS NOT NULL) h \n        GROUP BY participant_id) j) k group by felony;'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_in_custody","title":"<code>legal_in_custody(age=19, cutoff_date='active_date', tally=True)</code>","text":"<p>Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)</p> <p>Parameters:</p> Name Type Description Default <code>age</code> <p>the cutoff age of clients to search for, defaults to 19</p> <code>19</code> <code>cutoff</code> <code>date</code> <p>the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"</p> required <code>tally(Bool)</code> <p>True returns a count of clients, False offers a table. defaults to True</p> required <p>SQL Equivalent:</p> <pre><code>with custody_ids as \n(select distinct participant_id from \n    (select distinct participant_id from stints.classify_by_program\n    join civicore.participants using(participant_ID)\n    where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\njoin civicore.trunc_legal tl using(participant_id)\n)\nselect custody_status, count(distinct participant_id) from \n(select x.participant_id, x.recent_date, \n    group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n    group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n    group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n    group_concat(distinct comments SEPARATOR ', ') comments \nfrom \n    (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\ngroup by participant_id) y\ngroup by custody_status;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n        SQL Equivalent:\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True: \nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\nelse:\nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_in_custody_links","title":"<code>legal_in_custody_links()</code>","text":"<p>Returns the number of people in custody with linkages</p> <p>SQL Equivalent:</p> <pre><code>with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id);\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n        SQL Equivalent:\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\nquery = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_one_case","title":"<code>legal_one_case(timeframe=True)</code>","text":"<p>Returns counts of case outcomes for clients with one case</p> <p>Parameters:</p> Name Type Description Default <code>timeframe(Bool)</code> <p>if true, only looks at cases between T1 and T2. Defaults to True</p> required <p>SQL Equivalent:</p> <pre><code>with one_cases as (select * from \n    (select participant_id from \n        (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n        join civicore.legal l using(participant_id)\n        where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n        group by participant_id) d\n    where case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \nif timeframe is True:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\nelse:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_pending_cases","title":"<code>legal_pending_cases(t1_t2='t1', also_ended=False)</code>","text":"<p>Counts the number of people with pending cases at a given point</p> <p>Parameters:</p> Name Type Description Default <code>t1_t2</code> <p>the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end</p> <code>'t1'</code> <code>also_ended(Bool)</code> <p>True only counts clients who also had a case end. Defaults to False  </p> required <p>SQL Equivalent:</p> <pre><code>select count(distinct participant_id) from stints.classify_by_program\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n        SQL Equivalent:\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\nif t1_t2 == \"t1\": \nt1_t2 = self.q_t1\nelse:\nt1_t2 = self.q_t2\nif also_ended == False:\nquery = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\ndf = self.query_run(query)\nreturn df\nelse:\nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_program_involvement","title":"<code>legal_program_involvement(program_timeframe=False)</code>","text":"<p>returns linkage and case session tallies for clients with cases ended in a timeframe</p> <p>Parameters:</p> Name Type Description Default <code>program_timeframe</code> <p>True only counts linkages/case sessions in timeframe, defaults to False</p> <code>False</code> <p>SQL Equivalent:</p> <pre><code>with outcomes as (select participant_id, charge, case_type,\n    case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n    (select * from \n        (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n        GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n        GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n    group by participant_id, case_outcome) d1\nleft join tasks.highest_case using(case_outcome)) d),\nlinks as (select participant_id,\n    count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n    count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\nsessions as (select participant_id,\n    COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\nfrom stints.classify_by_program\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\ngroup by participant_id)\nselect o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\nleft join links l on o.participant_id = l.participant_id\nleft join sessions s on o.participant_id = s.participant_id;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>def legal_program_involvement(self, program_timeframe = False):\n'''\n    returns linkage and case session tallies for clients with cases ended in a timeframe\n    Parameters:\n        program_timeframe: True only counts linkages/case sessions in timeframe, defaults to False\n    SQL Equivalent:\n        with outcomes as (select participant_id, charge, case_type,\n            case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n            (select * from \n                (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n            join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n            group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)) d),\n        links as (select participant_id,\n            count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n            count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n            from civicore.linkages\n            where hub_initiated = \"yes\"\n            group by participant_id),\n        sessions as (select participant_id,\n            COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n            COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n        from stints.classify_by_program\n        join civicore.case_sessions using(participant_id)\n        where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n        group by participant_id)\n        select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n        left join links l on o.participant_id = l.participant_id\n        left join sessions s on o.participant_id = s.participant_id;\n    '''\nif program_timeframe is True: \nquery = f'''with outcomes as (select participant_id, charge, case_type,\n    case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)) d),\nlinks as (select participant_id,\ncount(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\ncount(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\nfrom civicore.linkages\nwhere hub_initiated = \"yes\"\ngroup by participant_id),\nsessions as (select participant_id,\n        COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\ngroup by participant_id)\nselect o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\nleft join links l on o.participant_id = l.participant_id\nleft join sessions s on o.participant_id = s.participant_id'''\nelse:\nquery = f'''with outcomes as (select participant_id, charge, case_type,\n    case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)) d),\nlinks as (select participant_id,\ncount(case when linked_date is not null then 1 else null end) as link_ct,\ncount(case when start_date is not null then 1 else null end) as start_ct\nfrom civicore.linkages\nwhere hub_initiated = \"yes\"\ngroup by participant_id),\nsessions as (select participant_id,\n        COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date is not null) and session_casenote = \"Casenote\"\ngroup by participant_id)\nselect o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\nleft join links l on o.participant_id = l.participant_id\nleft join sessions s on o.participant_id = s.participant_id'''\ndf = self.query_run(query)\ndf = df.fillna(0)\ndf['order'] = df.groupby('participant_id').cumcount() + 1\npivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\npivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\nmax_cases = df['order'].max()\ncase_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\ncase_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\nother_columns = [col for col in pivoted_df.columns if col not in case_columns]\npivoted_df = pivoted_df[case_columns + other_columns]\npivoted_df = pivoted_df.reset_index()\nif self.clipboard is True:\npivoted_df.to_clipboard()\nreturn pivoted_df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_rearrested","title":"<code>legal_rearrested(timeframe=True)</code>","text":"<p>Returns a count of clients rearrested</p> <p>Parameters:</p> Name Type Description Default <code>timeframe</code> <code>Bool</code> <p>True sums rearrests in the timeframe, False does not. Defaults to True</p> <code>True</code> <p>SQL Equivalent:</p> <pre><code>WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM stints.classify_by_program) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \non m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n        SQL Equivalent:\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\nif timeframe is True:\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.legal_tally","title":"<code>legal_tally(pending=False)</code>","text":"<p>Tallies clients with a case in CiviCore</p> <p>Parameters:</p> Name Type Description Default <code>pending</code> <code>Bool</code> <p>if True, tallies the clients with a case pending. Defaults to False. </p> <code>False</code> <p>SQL Equivalent:</p> <pre><code>with mlegal as \n    (select * from \n        (select participant_id, active_date, closed_date from stints.classify_by_program)k\n    join civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; '2023-08-31';\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n        SQL Equivalent:\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\nquery = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\nif pending is True:\nquery = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#linkages","title":"Linkages","text":"<p>             Bases: <code>Tables</code></p> <p>Sets up a table for a given timeframe</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <p>start date, formatted as \"YYYY-MM-DD\"</p> required <code>t2</code> <p>end date, formatted as \"YYYY-MM-DD\"</p> required <code>print_sql</code> <code>Bool</code> <p>whether to print the SQL statements when run, defaults to True</p> <code>True</code> <code>clipboard</code> <code>Bool</code> <p>whether to copy the output table to your clipboard, defaults to False</p> <code>False</code> <code>default_table</code> <p>the source table to run queries on. defaults to \"stints.classify_by_program\"</p> <code>'stints.classify_by_program'</code> Source code in <code>script\\nice_sql.py</code> <pre><code>class Queries(Tables):\n'''\n    Sets up a table for a given timeframe\n    Parameters:\n        t1: start date, formatted as \"YYYY-MM-DD\"\n        t2: end date, formatted as \"YYYY-MM-DD\"\n        print_sql (Bool): whether to print the SQL statements when run, defaults to True\n        clipboard (Bool): whether to copy the output table to your clipboard, defaults to False\n        default_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n    '''\ndef dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n        Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n            age: threshold at which a client is counted as a juvenile, defaults to 18\n            cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n        SQL Equivalent:\n            select \n                count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n            from stints.classify_by_program\n            join civicore.participants using(participant_id);'''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True:\nquery = f'''select \n                count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n                from {self.table}\n                join civicore.participants using(participant_id)'''\nelse: \nquery = f'''select \n                l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n                from {self.table} l\n                join civicore.participants using(participant_id)'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)\ndf = self.query_run(query)\nreturn(df)\ndef dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n        Returns a count of client races or genders\n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            race_gender: the category to tally, enter either \"race\" or \"gender\"\n        SQL Equivalent:\n            select race, count(distinct participant_id)\n            from stints.classify_by_program\n            join civicore.participants using(participant_id)\n            group by race;\n        '''\nquery = f'''select {race_gender}, count(distinct participant_id)\n        from {self.table}\n        join civicore.participants using(participant_id)\n        group by {race_gender}'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)  # Use self.query_modify here\ndf = self.query_run(query)\nreturn(df)\ndef dem_recent_address(self):\n'''\n        Finds the recent addresses of clients\n        SQL Equivalent:\n            with ranked_addresses as\n                (select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id \n                    ORDER BY primary_address DESC, entered_date DESC) AS rn \n                from stints.classify_by_program\n                join civicore.address a using(participant_id))\n                select * from ranked_addresses\n                where rn = 1\n                    ;\n        '''\ndef dem_recent_address(self, neighborhoods = False):\n'''\n        Finds the recent addresses of clients.\n        Parameters:\n            neighborhoods: True if using a table with neighborhoods. Defaults to False\n        '''\nif neighborhoods is False:\nquery = f'''with ranked_addresses as(select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n                    join civicore.address a using(participant_id))\n                    select * from ranked_addresses\n                    where rn = 1\n                    '''\nelse:\nquery = f'''WITH ranked_addresses AS (\n    SELECT\n        first_name,\n        last_name,\n        a.*,\n        ROW_NUMBER() OVER (\n            PARTITION BY participant_id\n            ORDER BY \n                primary_address DESC,\n                entered_date DESC,\n                CASE WHEN LOWER(neighborhood) not LIKE '%other%' THEN 1 ELSE 0 END\n        ) AS rn\n    FROM\n        (select distinct first_name, last_name, participant_id from {self.table}) s\n        JOIN tasks.neighborhoods a USING(participant_id)\n)\nSELECT participant_id, location, primary_address, entered_date, updated_date, neighborhood, rn\nFROM ranked_addresses\n'''\ndf = self.query_run(query)\nreturn(df)\ndef docs_has_formatted(self):\n'''\n        checks if clients have ISPs or Assessments and if they are formatted correctly\n        '''\nquery = f'''SELECT DISTINCT (participant_id), ASSM_ISP_formatted, has_ASSM_ISP, FCS_formatted, has_FCS,  BP_formatted, has_BP, PCL_formatted, has_PCL,  has_cdc, assess\nFROM (select * from {self.table}) cr\nLEFT JOIN( select participant_id, first_name, last_name\nfrom civicore.participants) p USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_ASSM_ISP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS ASSM_ISP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_ASSM_ISP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*'\nGROUP BY participant_id, Has_ASSM_ISP\n) assm USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_FCS_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS FCS_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*FCS.*|.*Crime.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_FCS\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*FCS.*|.*Crime.*'\nGROUP BY participant_id, has_FCS\n) fcs USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_BP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS BP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*BP.*|.*Buss.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_BP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*BP.*|.*Buss.*'\nGROUP BY participant_id, has_BP\n) bp USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_PCL_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS PCL_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_PCL\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*'\nGROUP BY participant_id, has_PCL\n) PCL USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_CDC_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS CDC_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_CDC\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*'\nGROUP BY participant_id, has_CDC\n) cdc USING (participant_id)\nleft join(\nselect participant_id,\n        COUNT(CASE\n                WHEN d.document_type = 'Assessments' THEN 1 ELSE NULL END) as assess\n from documents.unfiltered d\n group by participant_id) asseses USING (participant_id);'''\ndf = self.query_run(query)\nreturn df\ndef grant_tally(self, start_end = None):\n'''\n        counts how many clients are on a grant\n        Parameters\n            start_end: \"start_date\" returns clients who started in timeframe, \"end_date\" returns clients who ended\n        '''\nquery = f'''select grant_type, count(distinct participant_id) from {self.table} group by grant_type'''\nif start_end == \"start_date\":\nquery = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or active_date between {self.q_t1} and {self.q_t2}''')\nelif start_end == \"end_date\":\nquery = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or closed_date between {self.q_t1} and {self.q_t2}''')\ndf = self.query_run(query)\nreturn df\ndef incident_tally(self):\n'''\n        counts incidents in timeframe\n        '''\nquery = f'''SELECT count(case when how_hear regexp '.*CPIC.*' then incident_id else null end) as CPIC,\n\tcount(case when how_hear not regexp '.*CPIC.*' then incident_id else null end) as non_CPIC\nFROM civicore.critical_incidents\nwhere (date_incident between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\ndef legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n        SQL Equivalent:\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\nquery = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\nif pending is True:\nquery = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\ndf = self.query_run(query)\nreturn df\ndef legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n        SQL Equivalent:\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True: \nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\nelse:\nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\ndf = self.query_run(query)\nreturn df\ndef legal_program_involvement(self, program_timeframe = False):\n'''\n        returns linkage and case session tallies for clients with cases ended in a timeframe\n        Parameters:\n            program_timeframe: True only counts linkages/case sessions in timeframe, defaults to False\n        SQL Equivalent:\n            with outcomes as (select participant_id, charge, case_type,\n                case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n                (select * from \n                    (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                    GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)) d),\n            links as (select participant_id,\n                count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n                count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n                from civicore.linkages\n                where hub_initiated = \"yes\"\n                group by participant_id),\n            sessions as (select participant_id,\n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n            group by participant_id)\n            select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n            left join links l on o.participant_id = l.participant_id\n            left join sessions s on o.participant_id = s.participant_id;\n        '''\nif program_timeframe is True: \nquery = f'''with outcomes as (select participant_id, charge, case_type,\n        case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n        group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)) d),\n    links as (select participant_id,\n    count(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\n    count(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\n    sessions as (select participant_id,\n            COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n        COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id)\n    where (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\n    group by participant_id)\n    select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n    left join links l on o.participant_id = l.participant_id\n    left join sessions s on o.participant_id = s.participant_id'''\nelse:\nquery = f'''with outcomes as (select participant_id, charge, case_type,\n        case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n        group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)) d),\n    links as (select participant_id,\n    count(case when linked_date is not null then 1 else null end) as link_ct,\n    count(case when start_date is not null then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\n    sessions as (select participant_id,\n            COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n        COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id)\n    where (session_date is not null) and session_casenote = \"Casenote\"\n    group by participant_id)\n    select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n    left join links l on o.participant_id = l.participant_id\n    left join sessions s on o.participant_id = s.participant_id'''\ndf = self.query_run(query)\ndf = df.fillna(0)\ndf['order'] = df.groupby('participant_id').cumcount() + 1\npivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\npivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\nmax_cases = df['order'].max()\ncase_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\ncase_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\nother_columns = [col for col in pivoted_df.columns if col not in case_columns]\npivoted_df = pivoted_df[case_columns + other_columns]\npivoted_df = pivoted_df.reset_index()\nif self.clipboard is True:\npivoted_df.to_clipboard()\nreturn pivoted_df\ndef legal_fel_reduction(self, timeframe = True):\n'''\n        Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            select felony, count(felony) FROM \n                (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                    ELSE 'remained' \n                END AS felony from\n                    (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                            CASE\n                                WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                                ELSE 'Not Lower'\n                            END AS rank_comparison from civicore.legal lt \n                            join stints.classify_by_program using(participant_id) \n                            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                        GROUP BY participant_id) j\n                    ) k \n                group by felony;\n        '''\nif timeframe is True: \nquery = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n            GROUP BY participant_id) j) k group by felony;'''\nelse:\nquery = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL) h \n            GROUP BY participant_id) j) k group by felony;'''\ndf = self.query_run(query)\nreturn df\ndef legal_case_outcomes(self,  timeframe = True):\n'''\n        returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            with ranked_df as \n            (select * from \n                (SELECT participant_id, case_outcome, \n                GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n                GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                    (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)),\n            plea_concat as \n                (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n                else case_outcome end as case_outcome\n            from (select case_outcome, sentence from ranked_df d1\n            LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n            WHERE d2.ranking IS NULL)h)\n            select case_outcome, count(case_outcome) from plea_concat\n            group by case_outcome\n        '''\nif timeframe is True: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome\n        '''\nelse: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id)) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome'''\ndf = self.query_run(query)\nreturn df    \ndef legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n        SQL Equivalent:\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n        '''\nif timeframe is False:\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nrelevant_date = \"arrest_date\"\nelse:\nrelevant_date = \"case_outcome_date\"\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Plead Guilty' then 4\nwhen case_status_current = 'Found Guilty' then 5\nelse 6\nend asc'''\ndf = self.query_run(query)\nreturn df\ndef legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \nif timeframe is True:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\nelse:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\ndf = self.query_run(query)\nreturn df\ndef legal_case_type(self, timeframe = False, first_charge = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            first_charge(Bool): if true, only returns earliest case(s) in CiviCore. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n        SQL Equivalent:\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\nif case_client == \"case\":\ncase_client = \"case_id\"\nif case_client ==\"client\":\ncase_client = \"participant_id\"     \nif first_charge is True:\nquery = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\nelse: \nquery = f'''\n        WITH mlegal AS (SELECT *\n        FROM (\n            SELECT DISTINCT participant_id, active_date, closed_date\n            FROM {self.table}\n        ) k\n        JOIN civicore.legal l USING (participant_id)\n        JOIN tasks.last_close USING (participant_id)\n        WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n    )\n    select case_type,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n    from mlegal\n    group by case_type\n    ORDER BY case when case_type = 'property' then 1\n    when case_type = 'gun' then 2\n    when case_type = 'battery' then 3\n    when case_type = 'drug' then 4\n    when case_type = 'attempted murder' then 5\n    when case_type = 'murder' then 6\n    when case_type = 'other' then 7\n    else 8\n    end asc\n    '''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nopened_closed = \"arrest_date\"\nquery = self.query_modify(str(query), f'''where (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\nelse:\nopened_closed = \"case_outcome_date\"\nquery = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \ndf = self.query_run(query)\nif percentage is True:\ndf = self.percentage_convert(df, replace= False)\nreturn df    \ndef legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n        SQL Equivalent:\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\nquery = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\ndf = self.query_run(query)\nreturn df\ndef legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n        SQL Equivalent:\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\nif t1_t2 == \"t1\": \nt1_t2 = self.q_t1\nelse:\nt1_t2 = self.q_t2\nif also_ended == False:\nquery = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\ndf = self.query_run(query)\nreturn df\nelse:\nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\ndf = self.query_run(query)\nreturn df\ndef legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n        SQL Equivalent:\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\nif timeframe is True:\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \ndf = self.query_run(query)\nreturn df\ndef link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n        Returns the number of clients with at least one linkage\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n        SQL Equivalent:\n            select count(distinct participant_id) from \n                (select participant_id from stints.classify_by_program) x \n            join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n        '''\nquery = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\nif hub_initiated is False and timeframe is False:\ndf = self.query_run(query)\nreturn df\nif started_linked.lower() == \"both\":\nif hub_initiated is False:\nquery = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\nif hub_initiated is True and timeframe is False:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\nelse:\nif hub_initiated is False and timeframe is True:\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif hub_initiated is True and timeframe is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\ndf = self.query_run(query)\nreturn df\ndef link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n        SQL Equivalent:\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\nif cutoff_date == \"t1\":\ncutoff_date = self.t1\nif link_type.lower() == \"education\":\ninequality_sign = '&lt;'\nif link_type.lower() == \"employment\":\ninequality_sign = '&gt;'\nlink_type = f\"'{link_type}'\"\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nquery = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\nif hub_initiated == True:\nquery = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\nif first_n_months is not None:\nquery = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\ndf = self.query_run(query)\nreturn df\ndef link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n        SQL Equivalent:\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\nquery = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\nif timeframe == True:\nif started_linked == \"linked_date\" or started_linked == \"start_date\":\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif started_linked == \"both\" or started_linked == \"Both\":\nquery = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated == True:\nquery = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\nif timeframe == False and hub_initiated == True:\nquery = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\ndf = self.query_run(query)\nreturn df\ndef mediation_tally(self, followup = False):\n'''\n        counts number of mediations in timeframe\n        Parameters\n            followup (Bool): if True, returns followup mediation tally. Defaults to False\n        '''\nif followup == False:\nquery = f'''select outcome_mediation, count(outcome_mediation) from civicore.mediations\nwhere (date_start_mediation between{self.q_t1} and {self.q_t2})\ngroup by outcome_mediation'''\nelse:\nquery = f'''select outcome_mediation, count(outcome_mediation) from civicore.mediation_followup\n    where (date_session between{self.q_t1} and {self.q_t2})\n    group by outcome_mediation'''\ndf = self.query_run(query)\nreturn df\ndef mediation_time_spent(self):\n'''\n        sums the number of hours spent on mediations\n        '''\nquery = f'''select sum(hours_spent_mediation) from civicore.mediations where (date_conflict between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\ndef programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n        SQL Equivalent:\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n        '''\nquery = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\ndf = self.query_run(query)\nreturn df\ndef programs_service_tally(self, service_column):\n'''\n        Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n        Parameters:\n            Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n        SQL Equivalent: \n            select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n        '''\nif service_column.lower() == \"outreach\":\nquery = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\nelse:\nquery = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\ndf = self.query_run(query)\nreturn df\ndef outreach_tally(self):\n'''\n        counts clients receiving outreach\n        '''\nquery = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\ndf = self.query_run(query)\nreturn df\ndef programs_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n        Counts clients who have at least one recorded session with a case manager or outreach worker\n        Parameters:\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n        SQL Equivalent: \n            select count(distinct participant_id) from stints.classify_by_program \n            join civicore.case_sessions using(participant_id) \n            where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\ndf = self.query_run(query)\nreturn df\ndef programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n        SQL Equivalent:\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\ndf = self.query_run(query)\nreturn df\ndef programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n        SQL Equivalent:\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\nif demographic == \"age\" and self.joined_participants == False:\nquery = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\nelse:\nquery = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\nif self.joined_participants == False and demographic != \"age\":\nquery = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\ndf = self.query_run(query)\nif percentages == True:\ndf = self.percentage_convert(df)\nreturn df\ndef programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n        Finds the length of case management or outreach sessions\n        Parameters:\n            cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n            grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n        SQL Equivalent:\n            select \n                avg(hours) * 60 as overall,\n                avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\nif cm_outreach == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nif grouped is False:\nquery = f'''select \n            avg(hours) * 60 as overall,\n         avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\nif grouped is True:\nif timeframe is True:  \nquery = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\nelse: \nquery = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_casenote = {cm_outreach})\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\ndf = self.query_run(query)\nreturn df\ndef programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n        SQL Equivalent:\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\nquery = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.link_edu_job","title":"<code>link_edu_job(hub_initiated=True, link_type='education', age=19, cutoff_date='t1', first_n_months=None)</code>","text":"<p>Counts either meployment or education linkages among clients</p> <p>Parameters:</p> Name Type Description Default <code>hub_initiated</code> <code>Bool</code> <p>whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True</p> <code>True</code> <code>link_type</code> <p>\"education\" returns education linkages, while \"employment\" returns employment linkages</p> <code>'education'</code> <code>age</code> <p>the age cutoff for clients, defaults to 19</p> <code>19</code> <code>cutoff</code> <code>date</code> <p>the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"</p> required <code>first_n_months(integer)</code> <p>optional, only counts linkages made in the first N months of a client's stint</p> required <p>SQL Equivalent:</p> <pre><code>select count(distinct participant_id) from civicore.linkages l\njoin \n    (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n    join civicore.participants using(participant_ID)\n    where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n        SQL Equivalent:\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\nif cutoff_date == \"t1\":\ncutoff_date = self.t1\nif link_type.lower() == \"education\":\ninequality_sign = '&lt;'\nif link_type.lower() == \"employment\":\ninequality_sign = '&gt;'\nlink_type = f\"'{link_type}'\"\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nquery = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\nif hub_initiated == True:\nquery = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\nif first_n_months is not None:\nquery = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.link_goal_area","title":"<code>link_goal_area(hub_initiated=True, timeframe=True, started_linked='linked_date')</code>","text":"<p>Returns counts of linkages by goal area (service).</p> <p>Parameters:</p> Name Type Description Default <code>hub_initiated</code> <code>Bool</code> <p>whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True</p> <code>True</code> <code>timeframe</code> <code>Bool</code> <p>whether to only count linkages made between T1 and T2, defaults to True</p> <code>True</code> <code>started_linked</code> <p>only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"</p> <code>'linked_date'</code> <p>SQL Equivalent:</p> <pre><code>with separated_goals as \n    (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n    SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n        (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n        join civicore.linkages l using(participant_id)) s\n    JOIN (\n        SELECT 1 AS n UNION ALL\n        SELECT 2 UNION ALL\n        SELECT 3 UNION ALL\n        SELECT 4 UNION ALL\n        SELECT 5 UNION ALL\n        SELECT 6 UNION ALL\n        SELECT 7 UNION ALL\n        SELECT 8 UNION ALL\n        SELECT 9\n    ) AS numbers\n    ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\nwhere linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n        SQL Equivalent:\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\nquery = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\nif timeframe == True:\nif started_linked == \"linked_date\" or started_linked == \"start_date\":\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif started_linked == \"both\" or started_linked == \"Both\":\nquery = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated == True:\nquery = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\nif timeframe == False and hub_initiated == True:\nquery = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.link_tally","title":"<code>link_tally(hub_initiated=True, timeframe=False, started_linked='linked_date')</code>","text":"<p>Returns the number of clients with at least one linkage</p> <p>Parameters:</p> Name Type Description Default <code>hub_initiated</code> <code>Bool</code> <p>whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True</p> <code>True</code> <code>timeframe</code> <code>Bool</code> <p>whether to only count people who had at least one linkage between T1 and T2, defaults to False</p> <code>False</code> <code>started_linked</code> <p>only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"</p> <code>'linked_date'</code> <p>SQL Equivalent:</p> <pre><code>select count(distinct participant_id) from \n    (select participant_id from stints.classify_by_program) x \njoin civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>def link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n    Returns the number of clients with at least one linkage\n    Parameters:\n        hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n        timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n        started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n    SQL Equivalent:\n        select count(distinct participant_id) from \n            (select participant_id from stints.classify_by_program) x \n        join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n    '''\nquery = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\nif hub_initiated is False and timeframe is False:\ndf = self.query_run(query)\nreturn df\nif started_linked.lower() == \"both\":\nif hub_initiated is False:\nquery = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\nif hub_initiated is True and timeframe is False:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\nelse:\nif hub_initiated is False and timeframe is True:\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif hub_initiated is True and timeframe is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#programs","title":"Programs","text":"<p>             Bases: <code>Tables</code></p> <p>Sets up a table for a given timeframe</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <p>start date, formatted as \"YYYY-MM-DD\"</p> required <code>t2</code> <p>end date, formatted as \"YYYY-MM-DD\"</p> required <code>print_sql</code> <code>Bool</code> <p>whether to print the SQL statements when run, defaults to True</p> <code>True</code> <code>clipboard</code> <code>Bool</code> <p>whether to copy the output table to your clipboard, defaults to False</p> <code>False</code> <code>default_table</code> <p>the source table to run queries on. defaults to \"stints.classify_by_program\"</p> <code>'stints.classify_by_program'</code> Source code in <code>script\\nice_sql.py</code> <pre><code>class Queries(Tables):\n'''\n    Sets up a table for a given timeframe\n    Parameters:\n        t1: start date, formatted as \"YYYY-MM-DD\"\n        t2: end date, formatted as \"YYYY-MM-DD\"\n        print_sql (Bool): whether to print the SQL statements when run, defaults to True\n        clipboard (Bool): whether to copy the output table to your clipboard, defaults to False\n        default_table: the source table to run queries on. defaults to \"stints.classify_by_program\"\n    '''\ndef dem_age(self, new_clients = False, tally = True, age = 18, cutoff_date = \"active_date\"):\n'''\n        Returns a count of clients below/above a certain age threshold, or identifies clients as juveniles/adults \n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            tally (Bool): if true, returns a count of juv/adults, if false, returns a list. defaults to True\n            age: threshold at which a client is counted as a juvenile, defaults to 18\n            cutoff_date: time period at which to calculate age. defaults to \"active_date\", but one could also use a different column, \"t1\", or a date in \"YYYY-MM-DD\" format\n        SQL Equivalent:\n            select \n                count(distinct case when active_date&lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, active_date) BETWEEN 18 AND 25 then participant_id else null end) as 'Adult'\n            from stints.classify_by_program\n            join civicore.participants using(participant_id);'''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True:\nquery = f'''select \n                count(distinct case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then participant_id else null end) as 'Juvenile',\n                count(distinct case when TIMESTAMPDIFF(YEAR, birth_date, {cutoff_date}) BETWEEN {age} AND 25 then participant_id else null end) as 'Adult'\n                from {self.table}\n                join civicore.participants using(participant_id)'''\nelse: \nquery = f'''select \n                l.*, (case when {cutoff_date}&lt; DATE_ADD(birth_date, INTERVAL {age} YEAR) then 'Juvenile' else \"Adult\" end) as 'age_group'\n                from {self.table} l\n                join civicore.participants using(participant_id)'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)\ndf = self.query_run(query)\nreturn(df)\ndef dem_race_gender(self, new_clients = False, race_gender = None):\n'''\n        Returns a count of client races or genders\n        Parameters:\n            new_clients (Bool): if true, only counts clients who began between t1 and t2. defaults to False\n            race_gender: the category to tally, enter either \"race\" or \"gender\"\n        SQL Equivalent:\n            select race, count(distinct participant_id)\n            from stints.classify_by_program\n            join civicore.participants using(participant_id)\n            group by race;\n        '''\nquery = f'''select {race_gender}, count(distinct participant_id)\n        from {self.table}\n        join civicore.participants using(participant_id)\n        group by {race_gender}'''\nmodifier = f'''WHERE active_date between {self.q_t1} AND {self.q_t2}'''\nif new_clients is True:\nquery = self.query_modify(str(query), modifier)  # Use self.query_modify here\ndf = self.query_run(query)\nreturn(df)\ndef dem_recent_address(self):\n'''\n        Finds the recent addresses of clients\n        SQL Equivalent:\n            with ranked_addresses as\n                (select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id \n                    ORDER BY primary_address DESC, entered_date DESC) AS rn \n                from stints.classify_by_program\n                join civicore.address a using(participant_id))\n                select * from ranked_addresses\n                where rn = 1\n                    ;\n        '''\ndef dem_recent_address(self, neighborhoods = False):\n'''\n        Finds the recent addresses of clients.\n        Parameters:\n            neighborhoods: True if using a table with neighborhoods. Defaults to False\n        '''\nif neighborhoods is False:\nquery = f'''with ranked_addresses as(select first_name, last_name, a.*,\n                    ROW_NUMBER() OVER (partition by participant_id ORDER BY primary_address DESC, entered_date DESC) AS rn from {self.table}\n                    join civicore.address a using(participant_id))\n                    select * from ranked_addresses\n                    where rn = 1\n                    '''\nelse:\nquery = f'''WITH ranked_addresses AS (\n    SELECT\n        first_name,\n        last_name,\n        a.*,\n        ROW_NUMBER() OVER (\n            PARTITION BY participant_id\n            ORDER BY \n                primary_address DESC,\n                entered_date DESC,\n                CASE WHEN LOWER(neighborhood) not LIKE '%other%' THEN 1 ELSE 0 END\n        ) AS rn\n    FROM\n        (select distinct first_name, last_name, participant_id from {self.table}) s\n        JOIN tasks.neighborhoods a USING(participant_id)\n)\nSELECT participant_id, location, primary_address, entered_date, updated_date, neighborhood, rn\nFROM ranked_addresses\n'''\ndf = self.query_run(query)\nreturn(df)\ndef docs_has_formatted(self):\n'''\n        checks if clients have ISPs or Assessments and if they are formatted correctly\n        '''\nquery = f'''SELECT DISTINCT (participant_id), ASSM_ISP_formatted, has_ASSM_ISP, FCS_formatted, has_FCS,  BP_formatted, has_BP, PCL_formatted, has_PCL,  has_cdc, assess\nFROM (select * from {self.table}) cr\nLEFT JOIN( select participant_id, first_name, last_name\nfrom civicore.participants) p USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_ASSM_ISP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS ASSM_ISP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_ASSM_ISP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*ASSM.*|.*ISP.*|.*Matrix.*|.*service.*'\nGROUP BY participant_id, Has_ASSM_ISP\n) assm USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_FCS_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS FCS_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*FCS.*|.*Crime.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_FCS\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*FCS.*|.*Crime.*'\nGROUP BY participant_id, has_FCS\n) fcs USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_BP_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS BP_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*BP.*|.*Buss.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_BP\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*BP.*|.*Buss.*'\nGROUP BY participant_id, has_BP\n) bp USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_PCL_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS PCL_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_PCL\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*PCL.*|.*PLC.*|.*Post-Traumatic.*'\nGROUP BY participant_id, has_PCL\n) PCL USING (participant_id)\nLEFT JOIN(\nselect participant_id,\n        COUNT(CASE\n        WHEN d.document_name REGEXP '^.*_CDC_[01][0-9][0-3][0-9][12][0-9]{3}$' THEN 1\n        ELSE NULL END) AS CDC_formatted,\n    CASE\n        WHEN d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*' THEN 'Yes'\n        ELSE 'No'\n    END AS has_CDC\n from documents.unfiltered d\nWHERE d.document_name REGEXP '.*CDC.*|.*Achievement.*|.*_AM*'\nGROUP BY participant_id, has_CDC\n) cdc USING (participant_id)\nleft join(\nselect participant_id,\n        COUNT(CASE\n                WHEN d.document_type = 'Assessments' THEN 1 ELSE NULL END) as assess\n from documents.unfiltered d\n group by participant_id) asseses USING (participant_id);'''\ndf = self.query_run(query)\nreturn df\ndef grant_tally(self, start_end = None):\n'''\n        counts how many clients are on a grant\n        Parameters\n            start_end: \"start_date\" returns clients who started in timeframe, \"end_date\" returns clients who ended\n        '''\nquery = f'''select grant_type, count(distinct participant_id) from {self.table} group by grant_type'''\nif start_end == \"start_date\":\nquery = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or active_date between {self.q_t1} and {self.q_t2}''')\nelif start_end == \"end_date\":\nquery = self.query_modify(str(query), f'''where ({start_end} between {self.q_t1} and {self.q_t2}) or closed_date between {self.q_t1} and {self.q_t2}''')\ndf = self.query_run(query)\nreturn df\ndef incident_tally(self):\n'''\n        counts incidents in timeframe\n        '''\nquery = f'''SELECT count(case when how_hear regexp '.*CPIC.*' then incident_id else null end) as CPIC,\n\tcount(case when how_hear not regexp '.*CPIC.*' then incident_id else null end) as non_CPIC\nFROM civicore.critical_incidents\nwhere (date_incident between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\ndef legal_tally(self, pending = False):\n'''\n        Tallies clients with a case in CiviCore\n        Parameters:\n            pending (Bool): if True, tallies the clients with a case pending. Defaults to False. \n        SQL Equivalent:\n            with mlegal as \n                (select * from \n                    (select participant_id, active_date, closed_date from stints.classify_by_program)k\n                join civicore.legal l using(participant_id))\n            select count(distinct participant_id)\n            from mlegal where arrest_date &lt; '2023-08-31';\n        '''\nquery = f'''with mlegal as (select * from (select participant_id, active_date, closed_date from {self.table})k\njoin civicore.legal l using(participant_id))\nselect count(distinct participant_id)\nfrom mlegal where arrest_date &lt; {self.q_t2}'''\nif pending is True:\nquery = self.query_modify(str(query),f'''and (case_status_current regexp \"diversion.*|.*pending\" or case_outcome_date &gt; {self.q_t1})''')\ndf = self.query_run(query)\nreturn df\ndef legal_in_custody(self, age = 19, cutoff_date = 'active_date', tally = True):\n'''\n        Returns a table of clients in custody (or more realistically, whose last trunc_legal update was that they were in custody)\n        Parameters:\n            age: the cutoff age of clients to search for, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 'active_date' but one can also enter \"t1\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            tally(Bool): True returns a count of clients, False offers a table. defaults to True\n        SQL Equivalent:\n            with custody_ids as \n            (select distinct participant_id from \n                (select distinct participant_id from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where active_date &gt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) l\n            join civicore.trunc_legal tl using(participant_id)\n            )\n            select custody_status, count(distinct participant_id) from \n            (select x.participant_id, x.recent_date, \n                group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, \n                group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, \n                group_concat(distinct custody_status  SEPARATOR ', ') custody_status, \n                group_concat(distinct comments SEPARATOR ', ') comments \n            from \n                (select participant_id, max(trunc_date) as recent_date from custody_ids\n                left join civicore.trunc_legal using(participant_id)\n                group by participant_id) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            group by participant_id) y\n            group by custody_status;\n        '''\nif cutoff_date.lower() == \"t1\":\ncutoff_date = self.t1\nif cutoff_date.lower()  == \"t2\":\ncutoff_date = self.t2\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nif tally is True: \nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\nselect custody_status, count(distinct participant_id) from (select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', ') as legal_status, group_concat(distinct legal_status_detail SEPARATOR ', ') as legal_status_detail, group_concat(distinct custody_status  SEPARATOR ', ') custody_status, group_concat(distinct comments SEPARATOR ', ') comments from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id) y\n    group by custody_status'''\nelse:\nquery = f'''with custody_ids as (select distinct participant_id from (select distinct participant_id from {self.table}\n    join civicore.participants using(participant_ID)\n    where {cutoff_date} &gt; DATE_ADD(birth_date, INTERVAL {age} YEAR)) l\n    join civicore.trunc_legal tl using(participant_id)\n    )\n    select x.participant_id, x.recent_date, group_concat(distinct legal_status  SEPARATOR ', '), group_concat(distinct legal_status_detail SEPARATOR ', '), group_concat(distinct custody_status  SEPARATOR ', '), group_concat(distinct comments SEPARATOR ', ') from (select participant_id, max(trunc_date) as recent_date from custody_ids\n    left join civicore.trunc_legal using(participant_id)\n    group by participant_id) x\n    join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n    group by participant_id;'''\ndf = self.query_run(query)\nreturn df\ndef legal_program_involvement(self, program_timeframe = False):\n'''\n        returns linkage and case session tallies for clients with cases ended in a timeframe\n        Parameters:\n            program_timeframe: True only counts linkages/case sessions in timeframe, defaults to False\n        SQL Equivalent:\n            with outcomes as (select participant_id, charge, case_type,\n                case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from \n                (select * from \n                    (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, \n                    GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, \n                    GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n                    FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)) d),\n            links as (select participant_id,\n                count(case when linked_date between '2023-08-01' and '2023-08-31' then 1 else null end) as link_ct,\n                count(case when start_date between '2023-08-01' and '2023-08-31' then 1 else null end) as start_ct\n                from civicore.linkages\n                where hub_initiated = \"yes\"\n                group by participant_id),\n            sessions as (select participant_id,\n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\"\n            group by participant_id)\n            select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n            left join links l on o.participant_id = l.participant_id\n            left join sessions s on o.participant_id = s.participant_id;\n        '''\nif program_timeframe is True: \nquery = f'''with outcomes as (select participant_id, charge, case_type,\n        case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n        group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)) d),\n    links as (select participant_id,\n    count(case when linked_date between {self.q_t1} and {self.q_t2} then 1 else null end) as link_ct,\n    count(case when start_date between {self.q_t1} and {self.q_t2} then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\n    sessions as (select participant_id,\n            COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n        COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id)\n    where (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = \"Casenote\"\n    group by participant_id)\n    select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n    left join links l on o.participant_id = l.participant_id\n    left join sessions s on o.participant_id = s.participant_id'''\nelse:\nquery = f'''with outcomes as (select participant_id, charge, case_type,\n        case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", concat_sentence) else case_outcome end as case_outcome from (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT(distinct class_prior_to_plea_trial separator \", \") as charge, GROUP_CONCAT(DISTINCT case_type separator \", \") as case_type, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n        FROM (select participant_id, class_prior_to_plea_trial, case_type, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n        join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n        group by participant_id, case_outcome) d1\n        left join tasks.highest_case using(case_outcome)) d),\n    links as (select participant_id,\n    count(case when linked_date is not null then 1 else null end) as link_ct,\n    count(case when start_date is not null then 1 else null end) as start_ct\n    from civicore.linkages\n    where hub_initiated = \"yes\"\n    group by participant_id),\n    sessions as (select participant_id,\n            COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id else null END) AS unsuccessful,\n        COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id else null END) AS successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id)\n    where (session_date is not null) and session_casenote = \"Casenote\"\n    group by participant_id)\n    select o.participant_id, charge, case_type, case_outcome, link_ct linkages_made, start_ct linkages_started, successful, unsuccessful from outcomes o\n    left join links l on o.participant_id = l.participant_id\n    left join sessions s on o.participant_id = s.participant_id'''\ndf = self.query_run(query)\ndf = df.fillna(0)\ndf['order'] = df.groupby('participant_id').cumcount() + 1\npivoted_df = df.pivot_table(index=['participant_id', 'linkages_made', 'linkages_started', 'successful', 'unsuccessful'], columns=['order'], values=['charge', 'case_type', 'case_outcome'], aggfunc='first')\npivoted_df.columns = [f'{name}_{i}' for name, i in zip(pivoted_df.columns.get_level_values(0), pivoted_df.columns.get_level_values(1))]\nmax_cases = df['order'].max()\ncase_columns = [f'charge_{i}' for i in range(1, max_cases + 1)] + [f'case_type_{i}' for i in range(1, max_cases + 1)] + [f'case_outcome_{i}' for i in range(1, max_cases + 1)]\ncase_columns = [item for sublist in zip(case_columns[:max_cases], case_columns[max_cases*1:max_cases*2], case_columns[max_cases*2:]) for item in sublist]\nother_columns = [col for col in pivoted_df.columns if col not in case_columns]\npivoted_df = pivoted_df[case_columns + other_columns]\npivoted_df = pivoted_df.reset_index()\nif self.clipboard is True:\npivoted_df.to_clipboard()\nreturn pivoted_df\ndef legal_fel_reduction(self, timeframe = True):\n'''\n        Counts the number of clients who had their felony classes reduced after trial. Requires a felony_classes table\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            select felony, count(felony) FROM \n                (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n                    ELSE 'remained' \n                END AS felony from\n                    (SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n                        FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n                            CASE\n                                WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'\n                                ELSE 'Not Lower'\n                            END AS rank_comparison from civicore.legal lt \n                            join stints.classify_by_program using(participant_id) \n                            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n                            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n                            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN '2023-08-01' and '2023-08-31') h \n                        GROUP BY participant_id) j\n                    ) k \n                group by felony;\n        '''\nif timeframe is True: \nquery = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL AND case_outcome_date BETWEEN {self.q_t1} and {self.q_t2}) h \n            GROUP BY participant_id) j) k group by felony;'''\nelse:\nquery = f'''select felony, count(felony) FROM \n    (select CASE \n                    WHEN concatenated_values LIKE \"%Decreased%\" THEN 'lowered' \n            ELSE 'remained' END AS felony  \n            from(SELECT participant_id, GROUP_CONCAT(rank_comparison SEPARATOR ', ') AS concatenated_values \n            FROM (select lt.participant_id, lt.class_prior_to_plea_trial,  lt.class_after_plea_trial,  \n            CASE         \n                            WHEN crr1.ranking &lt; crr2.ranking THEN 'Decreased'         \n                            ELSE 'Not Lower'     \n                END AS rank_comparison from civicore.legal lt \n                    join {self.table} using(participant_id) \n            JOIN tasks.felony_classes crr1 ON lt.class_prior_to_plea_trial = crr1.class \n            JOIN tasks.felony_classes crr2 ON lt.class_after_plea_trial = crr2.class \n            where class_after_plea_trial IS NOT NULL) h \n            GROUP BY participant_id) j) k group by felony;'''\ndf = self.query_run(query)\nreturn df\ndef legal_case_outcomes(self,  timeframe = True):\n'''\n        returns a count of client legal outcomes, keeping the most severe for each client (ie: if a client gets probation and IDOC, only IDOC is counted). requires tasks.highest_case (ELI FIND THIS TOO)\n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            with ranked_df as \n            (select * from \n                (SELECT participant_id, case_outcome, \n                GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, \n                GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes FROM \n                    (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n                    join stints.classify_by_program using(participant_id) where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31') r\n                group by participant_id, case_outcome) d1\n            left join tasks.highest_case using(case_outcome)),\n            plea_concat as \n                (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) \n                else case_outcome end as case_outcome\n            from (select case_outcome, sentence from ranked_df d1\n            LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n            WHERE d2.ranking IS NULL)h)\n            select case_outcome, count(case_outcome) from plea_concat\n            group by case_outcome\n        '''\nif timeframe is True: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead guilty\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome\n        '''\nelse: \nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\n    FROM (select participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\n    join {self.table} using(participant_id)) r\n    group by participant_id, case_outcome) d1\n    left join tasks.highest_case using(case_outcome)), \n    plea_concat as (select case when case_outcome like \"plead%\" then concat(case_outcome, \" - \", sentence) else case_outcome end as case_outcome\n    from (select case_outcome, sentence from ranked_df d1\n    LEFT JOIN (select participant_id, ranking from ranked_df) d2 ON d1.participant_id = d2.participant_id AND d1.ranking &lt; d2.ranking\n    WHERE\n        d2.ranking IS NULL)h)\n    select case_outcome, count(case_outcome) from plea_concat\n    group by case_outcome'''\ndf = self.query_run(query)\nreturn df    \ndef legal_case_statuses(self, timeframe = False, opened_closed = \"closed\"):\n'''\n        returns a count of client case statuses at a given time, or the count of open/closed cases between t1 and t2\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n        SQL Equivalent:\n            with mlegal as (select * from (select participant_id, active_date from stints.classify_by_program) m\n            join civicore.legal l using(participant_id))\n            select case_status_current,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\n            group by case_status_current\n            UNION ALL\n            select case_outcome,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\n                COUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\n            from mlegal n\n            WHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\n            group by case_outcome\n            order by case when case_status_current = 'Case Pending' then 1\n                        when case_status_current = 'Case Closed' then 2\n                        when case_status_current = 'Dismissed' then 3\n                        when case_status_current = 'Plead Guilty' then 4\n                        when case_status_current = 'Found Guilty' then 5\n                        else 6\n                        end asc;\n        '''\nif timeframe is False:\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\"\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 60 DAY) AND case_outcome IS NOT NULL\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\n            when case_status_current = 'Case Closed' then 2\n            when case_status_current = 'Dismissed' then 3\n            when case_status_current = 'Plead Guilty' then 4\n            when case_status_current = 'Found Guilty' then 5\n            else 6\n            end asc'''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nrelevant_date = \"arrest_date\"\nelse:\nrelevant_date = \"case_outcome_date\"\nquery = f'''with mlegal as (select * from (select participant_id, active_date from {self.table}) m\njoin civicore.legal l using(participant_id))\nselect case_status_current,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 45 DAY) AND case_status_current regexp \"Case Pending|Case Closed|Probation\" and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_status_current\nUNION ALL \nselect case_outcome,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Felony%\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge LIKE \"%Misdemeanor%\" THEN case_id END) AS Misdemeanor\nfrom mlegal n\nWHERE active_date &lt;= DATE_ADD(arrest_date, INTERVAL 30 DAY) AND case_outcome IS NOT NULL and ({relevant_date} between {self.q_t1} and {self.q_t2})\ngroup by case_outcome\norder by case when case_status_current = 'Case Pending' then 1\nwhen case_status_current = 'Case Closed' then 2\nwhen case_status_current = 'Dismissed' then 3\nwhen case_status_current = 'Plead Guilty' then 4\nwhen case_status_current = 'Found Guilty' then 5\nelse 6\nend asc'''\ndf = self.query_run(query)\nreturn df\ndef legal_one_case(self, timeframe = True):\n'''\n        Returns counts of case outcomes for clients with one case\n        Parameters:\n            timeframe(Bool): if true, only looks at cases between T1 and T2. Defaults to True\n        SQL Equivalent:\n            with one_cases as (select * from \n                (select participant_id from \n                    (select participant_id, count(distinct participant_id) as case_count from stints.classify_by_program\n                    join civicore.legal l using(participant_id)\n                    where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31'\n                    group by participant_id) d\n                where case_count = 1) e\n            join civicore.legal using(participant_id)\n            where case_outcome_date BETWEEN '2023-08-01' AND '2023-08-31')\n            select case_outcome, count(case_outcome) from one_cases\n            group by case_outcome;\n        '''       \nif timeframe is True:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id)\nwhere case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2})\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\nelse:\nquery = f'''with one_cases as (select * from (select participant_id from (select participant_id, count(distinct participant_id) as case_count from {self.table}\njoin civicore.legal l using(participant_id)\ngroup by participant_id) d\nwhere case_count = 1) e\njoin civicore.legal using(participant_id))\nselect case_outcome, count(case_outcome) from one_cases\ngroup by case_outcome'''\ndf = self.query_run(query)\nreturn df\ndef legal_case_type(self, timeframe = False, first_charge = False, opened_closed = \"opened\", percentage = False, case_client = \"case\"):\n'''\n        Returns counts of cases by type (gun, drug, etc) \n        Parameters:\n            timeframe (Bool): if true, only looks at cases between T1 and T2. Defaults to False\n            first_charge(Bool): if true, only returns earliest case(s) in CiviCore. Defaults to False\n            opened_closed: only needed if timeframe is True. \"closed\" returns a count of clients whose cases closed in the timeframe, \"opened\" returns cases opened\n            percentage (Bool): if True, returns a percentage breakdown. Defaults to False\n            case_client: \"case\" counts number of cases, \"client\" counts number of clients. Defaults to \"case\"\n        SQL Equivalent:\n            WITH mleg AS (\n                SELECT *\n                FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM participants.hd\n                ) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n            ),\n                mlegal AS (\n                SELECT m1.*\n                FROM mleg m1\n                JOIN (\n                    SELECT participant_id, MIN(arrest_date) AS min_date\n                    FROM mleg\n                    GROUP BY participant_id\n                ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n            )\n            select case_type,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n            COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n            from mlegal\n            group by case_type\n            ORDER BY case when case_type = 'property' then 1\n            when case_type = 'gun' then 2\n            when case_type = 'battery' then 3\n            when case_type = 'drug' then 4\n            when case_type = 'attempted murder' then 5\n            when case_type = 'murder' then 6\n            when case_type = 'other' then 7\n            else 8\n            end asc\n        '''\nif case_client == \"case\":\ncase_client = \"case_id\"\nif case_client ==\"client\":\ncase_client = \"participant_id\"     \nif first_charge is True:\nquery = f'''\n    WITH mleg AS (SELECT *\n    FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n),\n    mlegal AS (\n    SELECT m1.* FROM mleg m1\n    JOIN (\n        SELECT participant_id, MIN(arrest_date) AS min_date\n        FROM mleg\n        GROUP BY participant_id\n    ) m2 ON m1.participant_id = m2.participant_id AND m1.arrest_date = m2.min_date\n)\nselect case_type,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\nCOUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\nfrom mlegal\ngroup by case_type\nORDER BY case when case_type = 'property' then 1\nwhen case_type = 'gun' then 2\nwhen case_type = 'battery' then 3\nwhen case_type = 'drug' then 4\nwhen case_type = 'attempted murder' then 5\nwhen case_type = 'murder' then 6\nwhen case_type = 'other' then 7\nelse 8\nend asc\n'''\nelse: \nquery = f'''\n        WITH mlegal AS (SELECT *\n        FROM (\n            SELECT DISTINCT participant_id, active_date, closed_date\n            FROM {self.table}\n        ) k\n        JOIN civicore.legal l USING (participant_id)\n        JOIN tasks.last_close USING (participant_id)\n        WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date\n    )\n    select case_type,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Felony.*\" THEN case_id END) AS Felony,\n    COUNT(DISTINCT CASE WHEN charge regexp \"Misdemeanor.*\" THEN case_id END) AS Misdemeanor\n    from mlegal\n    group by case_type\n    ORDER BY case when case_type = 'property' then 1\n    when case_type = 'gun' then 2\n    when case_type = 'battery' then 3\n    when case_type = 'drug' then 4\n    when case_type = 'attempted murder' then 5\n    when case_type = 'murder' then 6\n    when case_type = 'other' then 7\n    else 8\n    end asc\n    '''\nif timeframe is True:\nif opened_closed.lower() == \"opened\" or opened_closed.lower() == \"open\":\nopened_closed = \"arrest_date\"\nquery = self.query_modify(str(query), f'''where (({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}) or (active_date BETWEEN {self.q_t1} AND {self.q_t2}))''')\nelse:\nopened_closed = \"case_outcome_date\"\nquery = self.query_modify(str(query), f'''and(({opened_closed} BETWEEN {self.q_t1} AND {self.q_t2}))''')     \ndf = self.query_run(query)\nif percentage is True:\ndf = self.percentage_convert(df, replace= False)\nreturn df    \ndef legal_in_custody_links(self):\n'''\n        Returns the number of people in custody with linkages\n        SQL Equivalent:\n            with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from stints.classify_by_program c\n            left join civicore.trunc_legal tl using(participant_id)\n            group by participant_id, active_date) x\n            join civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\n            where active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\n            select count(distinct participant_id) from recent_custody\n            join civicore.linkages using(participant_id);\n        '''\nquery = f'''with recent_custody as(select x.participant_id, l.custody_status from  (select participant_id, active_date, max(trunc_date) as recent_date from {self.table} c\nleft join civicore.trunc_legal tl using(participant_id)\ngroup by participant_id, active_date) x\njoin civicore.trunc_legal l on x.participant_id = l.participant_id and x.recent_date = l.trunc_date\nwhere active_date &lt;= DATE_ADD(trunc_date, INTERVAL 45 DAY) and custody_status = 'In Custody (+)')\nselect count(distinct participant_id) from recent_custody\njoin civicore.linkages using(participant_id)'''\ndf = self.query_run(query)\nreturn df\ndef legal_pending_cases(self, t1_t2 = \"t1\", also_ended = False):\n'''\n        Counts the number of people with pending cases at a given point\n        Parameters:\n            t1_t2: the date on which to tally. \"t1\" uses the start of the stint, \"t2\" uses the end\n            also_ended(Bool): True only counts clients who also had a case end. Defaults to False  \n        SQL Equivalent:\n            select count(distinct participant_id) from stints.classify_by_program\n                join civicore.legal using(participant_id)\n                where arrest_date &lt; '2023-08-01' and (case_status_current like \"Case Pending\" or case_outcome_date &gt; '2023-08-01');\n        '''\nif t1_t2 == \"t1\": \nt1_t2 = self.q_t1\nelse:\nt1_t2 = self.q_t2\nif also_ended == False:\nquery = f'''select count(distinct participant_id) from {self.table}\n    join civicore.legal using(participant_id)\n    where arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2})'''\ndf = self.query_run(query)\nreturn df\nelse:\nquery = f'''with ranked_df as (select * from (SELECT participant_id, case_outcome, GROUP_CONCAT( DISTINCT sentence SEPARATOR ', ') AS concat_sentence, GROUP_CONCAT(conditions_notes SEPARATOR ', ') AS concat_notes\nFROM (select  participant_id, conditions_notes, case_id, case_status_current, case_outcome, case_outcome_date, sentence from civicore.legal\njoin {self.table} using(participant_id) where case_outcome_date BETWEEN {self.q_t1} AND {self.q_t2}) r\ngroup by participant_id, case_outcome) d1),\npending as (select participant_id from {self.table}\njoin civicore.legal using(participant_id)\nwhere arrest_date &lt; {t1_t2} and (case_status_current like \"Case Pending\" or case_outcome_date &gt; {t1_t2}))\nselect count(distinct participant_id)\nfrom ranked_df\njoin pending using(participant_id)'''\ndf = self.query_run(query)\nreturn df\ndef legal_rearrested(self, timeframe = True):\n'''\n        Returns a count of clients rearrested\n        Parameters:\n            timeframe (Bool): True sums rearrests in the timeframe, False does not. Defaults to True\n        SQL Equivalent:\n            WITH mlegal AS (SELECT * FROM (\n                    SELECT DISTINCT participant_id, active_date, closed_date\n                    FROM stints.classify_by_program) k\n                JOIN civicore.legal l USING (participant_id)\n                JOIN tasks.last_close USING (participant_id)\n                WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\n            select count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\n            from mlegal m1\n            join (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 \n            on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s;\n        '''\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s'''\nif timeframe is True:\nquery = f'''WITH mlegal AS (SELECT * FROM (\n        SELECT DISTINCT participant_id, active_date, closed_date\n        FROM {self.table}\n    ) k\n    JOIN civicore.legal l USING (participant_id)\n    JOIN tasks.last_close USING (participant_id)\n    WHERE last_closed_date IS NULL OR arrest_date &gt; last_closed_date)\nselect count(distinct participant_id) from (select m1.participant_id, active_date, case_id, arrest_date, offense_date\nfrom mlegal m1\njoin (select participant_id, min(arrest_date) as min_date from mlegal group by participant_id) m2 on m1.participant_id = m2.participant_id and m1.arrest_date &gt; m2.min_date) s\nwhere arrest_date between {self.q_t1} and {self.q_t2}''' \ndf = self.query_run(query)\nreturn df\ndef link_tally(self, hub_initiated = True, timeframe = False, started_linked = \"linked_date\"):\n'''\n        Returns the number of clients with at least one linkage\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to False\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n        SQL Equivalent:\n            select count(distinct participant_id) from \n                (select participant_id from stints.classify_by_program) x \n            join civicore.linkages using (participant_id) where hub_initiated = \"yes\";\n        '''\nquery = f'''select count(distinct participant_id) from (select participant_id from {self.table}) x join civicore.linkages using (participant_id)'''\nif hub_initiated is False and timeframe is False:\ndf = self.query_run(query)\nreturn df\nif started_linked.lower() == \"both\":\nif hub_initiated is False:\nquery = self.query_modify(str(query), f'''where (linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ((linked_date between {self.q_t1} and {self.q_t2}) or (start_date between {self.q_t1} and {self.q_t2}))''')\nif hub_initiated is True and timeframe is False:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\"''')\nelse:\nif hub_initiated is False and timeframe is True:\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif hub_initiated is True and timeframe is True:\nquery = self.query_modify(str(query), f'''where hub_initiated = \"yes\" and ({started_linked} between {self.q_t1} and {self.q_t2})''')\ndf = self.query_run(query)\nreturn df\ndef link_edu_job(self, hub_initiated = True, link_type = \"education\", age = 19, cutoff_date = 't1', first_n_months = None):\n'''\n        Counts either meployment or education linkages among clients\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            link_type: \"education\" returns education linkages, while \"employment\" returns employment linkages\n            age: the age cutoff for clients, defaults to 19\n            cutoff date: the date on which to calculate clients ages, defaults to 't1' but one can also enter \"active_date\", \"t2\" or a date formatted as \"YYYY-MM-DD\"\n            first_n_months(integer): optional, only counts linkages made in the first N months of a client's stint\n        SQL Equivalent:\n            select count(distinct participant_id) from civicore.linkages l\n            join \n                (select participant_id, birth_date, active_date, \"2023-08-01\" from stints.classify_by_program\n                join civicore.participants using(participant_ID)\n                where \"2023-08-01\" &lt; DATE_ADD(birth_date, INTERVAL 19 YEAR)) fccc using (participant_id)\n            join(civicore.participants p) using(participant_id)\n            where l.linkage_type = 'education' AND linked_date &gt; active_date and hub_initiated = \"yes\";\n        '''\nif cutoff_date == \"t1\":\ncutoff_date = self.t1\nif link_type.lower() == \"education\":\ninequality_sign = '&lt;'\nif link_type.lower() == \"employment\":\ninequality_sign = '&gt;'\nlink_type = f\"'{link_type}'\"\nif cutoff_date.lower() != \"active_date\":\ncutoff_date = f'\"{cutoff_date}\"'\nquery = f'''select count(distinct participant_id) from civicore.linkages l\njoin (select participant_id, birth_date, active_date, {cutoff_date} from {self.table}\njoin civicore.participants using(participant_ID)\nwhere {cutoff_date} {inequality_sign} DATE_ADD(birth_date, INTERVAL {age} YEAR)) fccc using (participant_id)\njoin(civicore.participants p) using(participant_id)\nwhere l.linkage_type = {link_type} AND linked_date &gt; active_date'''\nif hub_initiated == True:\nquery = self.query_modify(str(query), f'''and hub_initiated = \"yes\"''')\nif first_n_months is not None:\nquery = self.query_modify(str(query), f'''AND DATEDIFF(active_date, l.linked_date) &lt;= {first_n_months} * 30.5''')\ndf = self.query_run(query)\nreturn df\ndef link_goal_area(self, hub_initiated = True, timeframe = True, started_linked = \"linked_date\"):\n'''\n        Returns counts of linkages by goal area (service).\n        Parameters:\n            hub_initiated (Bool): whether to exclusively count hub_initiated linkages. Note that \"False\" returns a count of both hub initiated and non hub initiated linkages. Defaults to True\n            timeframe (Bool): whether to only count linkages made between T1 and T2, defaults to True\n            started_linked: only needed if timeframe is True. \"linked_date\" counts linkages initiated , \"start_date\" counts those that started, and \"both\" counts both cases. Defaults to \"linked_date\"\n        SQL Equivalent:\n            with separated_goals as \n                (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, \n                SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area FROM \n                    (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from stints.classify_by_program p\n                    join civicore.linkages l using(participant_id)) s\n                JOIN (\n                    SELECT 1 AS n UNION ALL\n                    SELECT 2 UNION ALL\n                    SELECT 3 UNION ALL\n                    SELECT 4 UNION ALL\n                    SELECT 5 UNION ALL\n                    SELECT 6 UNION ALL\n                    SELECT 7 UNION ALL\n                    SELECT 8 UNION ALL\n                    SELECT 9\n                ) AS numbers\n                ON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\n            select separated_area, count(distinct participant_id)\n            from separated_goals\n            where linked_date between '2023-08-01' and '2023-08-31' and hub_initiated = 'Yes' group by separated_area;\n        '''\nquery = f'''with separated_goals as (SELECT participant_id, first_name, last_name, linkage_type, linkage_org, linked_date, s.start_date, hub_initiated, SUBSTRING_INDEX(SUBSTRING_INDEX(goal_area, ', ', n), ', ', -1) AS separated_area\nFROM (select participant_id, first_name, last_name, linkage_type, linkage_org, goal_area, linked_date, l.start_date, hub_initiated from {self.table} p\njoin civicore.linkages l using(participant_id)) s\nJOIN (\n    SELECT 1 AS n UNION ALL\n    SELECT 2 UNION ALL\n    SELECT 3 UNION ALL\n    SELECT 4 UNION ALL\n    SELECT 5 UNION ALL\n    SELECT 6 UNION ALL\n    SELECT 7 UNION ALL\n    SELECT 8 UNION ALL\n    SELECT 9\n) AS numbers\nON CHAR_LENGTH(goal_area) - CHAR_LENGTH(REPLACE(goal_area, ',', '')) &gt;= n - 1)\nselect separated_area, count(distinct participant_id)\nfrom separated_goals\ngroup by separated_area\n'''\nif timeframe == True:\nif started_linked == \"linked_date\" or started_linked == \"start_date\":\nquery = self.query_modify(str(query), f'''where {started_linked} between {self.q_t1} and {self.q_t2}''')\nif started_linked == \"both\" or started_linked == \"Both\":\nquery = self.query_modify(str(query), f'''where (start_date between {self.q_t1} and {self.q_t2} or linked_date between {self.q_t1} and {self.q_t2})''')\nif hub_initiated == True:\nquery = self.query_modify(str(query), \"and hub_initiated = 'Yes'\")\nif timeframe == False and hub_initiated == True:\nquery = self.query_modify(str(query), \"where hub_initiated = 'Yes'\")\ndf = self.query_run(query)\nreturn df\ndef mediation_tally(self, followup = False):\n'''\n        counts number of mediations in timeframe\n        Parameters\n            followup (Bool): if True, returns followup mediation tally. Defaults to False\n        '''\nif followup == False:\nquery = f'''select outcome_mediation, count(outcome_mediation) from civicore.mediations\nwhere (date_start_mediation between{self.q_t1} and {self.q_t2})\ngroup by outcome_mediation'''\nelse:\nquery = f'''select outcome_mediation, count(outcome_mediation) from civicore.mediation_followup\n    where (date_session between{self.q_t1} and {self.q_t2})\n    group by outcome_mediation'''\ndf = self.query_run(query)\nreturn df\ndef mediation_time_spent(self):\n'''\n        sums the number of hours spent on mediations\n        '''\nquery = f'''select sum(hours_spent_mediation) from civicore.mediations where (date_conflict between {self.q_t1} and {self.q_t2})'''\ndf = self.query_run(query)\nreturn df\ndef programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n        SQL Equivalent:\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n        '''\nquery = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\ndf = self.query_run(query)\nreturn df\ndef programs_service_tally(self, service_column):\n'''\n        Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n        Parameters:\n            Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n        SQL Equivalent: \n            select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n        '''\nif service_column.lower() == \"outreach\":\nquery = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\nelse:\nquery = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\ndf = self.query_run(query)\nreturn df\ndef outreach_tally(self):\n'''\n        counts clients receiving outreach\n        '''\nquery = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\ndf = self.query_run(query)\nreturn df\ndef programs_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n        Counts clients who have at least one recorded session with a case manager or outreach worker\n        Parameters:\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n        SQL Equivalent: \n            select count(distinct participant_id) from stints.classify_by_program \n            join civicore.case_sessions using(participant_id) \n            where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\ndf = self.query_run(query)\nreturn df\ndef programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n        SQL Equivalent:\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\ndf = self.query_run(query)\nreturn df\ndef programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n        SQL Equivalent:\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\nif demographic == \"age\" and self.joined_participants == False:\nquery = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\nelse:\nquery = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\nif self.joined_participants == False and demographic != \"age\":\nquery = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\ndf = self.query_run(query)\nif percentages == True:\ndf = self.percentage_convert(df)\nreturn df\ndef programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n        Finds the length of case management or outreach sessions\n        Parameters:\n            cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n            grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n            timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n        SQL Equivalent:\n            select \n                avg(hours) * 60 as overall,\n                avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n        '''\nif cm_outreach == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nif grouped is False:\nquery = f'''select \n            avg(hours) * 60 as overall,\n         avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\n    from {self.table}\n    join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\nif grouped is True:\nif timeframe is True:  \nquery = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\nelse: \nquery = f'''with hr_avg as (select \n        c.*,\n        case \n        when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n        when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n        when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n        when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n        when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n        when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n        when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n        when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n        when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n        when hours &gt; 2 then \"2+\"\n        end as session_length\n    from {self.table}\n    join civicore.case_sessions c using(participant_id)\n    where session_casenote = {cm_outreach})\n    select session_length, count(session_length)\n    from hr_avg\n    group by session_length\n    order by case when session_length = '0' then 1\n                when session_length = '0-.25' then 2\n                when session_length = '.26-.5' then 3\n                when session_length = '.51-.75' then 4\n                when session_length = '.76-1' then 5\n                when session_length = '1-1.25' then 6\n                when session_length = '1.26-1.5' then 7\n                when session_length = '1.51-1.75' then 8\n                when session_length = '1.76-2' then 9\n                when session_length = '2+' then 10\n                else 0\n                end asc'''\ndf = self.query_run(query)\nreturn df\ndef programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n        SQL Equivalent:\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\nquery = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.programs_by_demographic","title":"<code>programs_by_demographic(demographic=None, percentages=False)</code>","text":"<p>Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")</p> <p>Parameters:</p> Name Type Description Default <code>demographic</code> <p>the demographic of choice (\"age\", \"race\", \"gender\")</p> <code>None</code> <p>SQL Equivalent:</p> <pre><code>select gender, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from stints.classify_by_program\n    join civicore.participants using(participant_id) group by gender;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def programs_by_demographic(self, demographic = None, percentages = False):\n'''\n        Tallies program involvement by demographic feature(\"age\", \"race\", \"gender\")\n        Parameters:\n            demographic: the demographic of choice (\"age\", \"race\", \"gender\")\n        SQL Equivalent:\n            select gender, \n                COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n                COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n                COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n                COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n                COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n                COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n                from stints.classify_by_program\n                join civicore.participants using(participant_id) group by gender;\n        '''\nif demographic == \"age\" and self.joined_participants == False:\nquery = f'''select age, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from (select *, \ncase when {self.q_t1} &lt; DATE_ADD(birth_date, INTERVAL 18 YEAR) then \"juvenile\" else \"emerging adult\" end as \"age\"\nfrom {self.table}\njoin (select participant_id, birth_date, race, gender from civicore.participants) x using(participant_id)) y\n    group by age'''\nelse:\nquery = f'''select {demographic}, \n    COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS HD,\n    COUNT(DISTINCT CASE WHEN cm_juv_divert = 1 THEN participant_id END) AS juv_div,\n    COUNT(DISTINCT CASE WHEN cm_scan = 1 THEN participant_id END) AS SCaN,\n    COUNT(DISTINCT CASE WHEN rjcc = 1 THEN participant_id END) AS RJCC,\n    COUNT(DISTINCT CASE WHEN grant_type regexp \".*JAC.*\" THEN participant_id END) AS JAC,\n    COUNT(DISTINCT CASE WHEN vp = 1 AND grant_type regexp \".*IDHS.*\" THEN participant_id END) AS IDHS\n    from {self.table}     group by {demographic}'''\nif self.joined_participants == False and demographic != \"age\":\nquery = self.query_modify(str(query), f'''join civicore.participants using(participant_id)''')\ndf = self.query_run(query)\nif percentages == True:\ndf = self.percentage_convert(df)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.programs_packages","title":"<code>programs_packages()</code>","text":"<p>Provides counts and percentages of different program combinations</p> <p>SQL Equivalent:</p> <pre><code>WITH services_row as \n(SELECT participant_id,\n    GROUP_CONCAT(distinct CASE\n        WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n        END) AS Legal,\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n        END) AS \"CM\",\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n        END) AS YIP,\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n        END) AS SCaN,\n    GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n        ELSE NULL\n        END) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT CASE\n        WHEN hd = 1 THEN 'HD'\n        ELSE NULL\n        END) AS HD,\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN rjcc = 1 THEN 'RJCC'\n        ELSE NULL\n        END) AS RJCC,\n    GROUP_CONCAT(DISTINCT CASE\n        WHEN crws = 1 THEN 'CRwS'\n        ELSE NULL\n        END) AS CRwS,\n    GROUP_CONCAT(distinct CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END) AS VP\nFROM stints.classify_by_program\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n    OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n    OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n    ) AS concatenated_services\nFROM (services_row))\nselect concatenated_services, count(concatenated_services), \ncount(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def programs_packages(self):\n'''\n        Provides counts and percentages of different program combinations\n        SQL Equivalent:\n            WITH services_row as \n            (SELECT participant_id,\n                GROUP_CONCAT(distinct CASE\n                    WHEN service_legal = 1 THEN 'Legal' ELSE NULL\n                    END) AS Legal,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN service_cm = 1 THEN 'Case Management' ELSE NULL\n                    END) AS \"CM\",\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_juv_divert = 1 THEN 'YIP' ELSE NULL\n                    END) AS YIP,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN cm_scan = 1 THEN 'SCaN' ELSE NULL\n                    END) AS SCaN,\n                GROUP_CONCAT(DISTINCT CASE WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n                    ELSE NULL\n                    END) AS \"SCaN_Outreach\",\n                GROUP_CONCAT( DISTINCT CASE\n                    WHEN hd = 1 THEN 'HD'\n                    ELSE NULL\n                    END) AS HD,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN rjcc = 1 THEN 'RJCC'\n                    ELSE NULL\n                    END) AS RJCC,\n                GROUP_CONCAT(DISTINCT CASE\n                    WHEN crws = 1 THEN 'CRwS'\n                    ELSE NULL\n                    END) AS CRwS,\n                GROUP_CONCAT(distinct CASE\n                        WHEN vp = 1 THEN 'VP'\n                        ELSE NULL\n                    END) AS VP\n            FROM stints.classify_by_program\n            WHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n                OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n                OR rjcc = 1 OR crws = 1 OR vp = 1\n            GROUP BY participant_id),\n            concat_services as (SELECT\n                participant_id,\n                CONCAT_WS(' + ', Legal, CM, YIP, SCaN, SCaN_Outreach, HD, RJCC, CRwS, VP\n                ) AS concatenated_services\n            FROM (services_row))\n            select concatenated_services, count(concatenated_services), \n            count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage\n            from concat_services\n            group by concatenated_services\n            order by count(concatenated_services) desc;\n        '''\nquery = f'''WITH services_row as \n(SELECT\n    participant_id,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN service_legal = 1 THEN 'Legal'\n            ELSE NULL\n        END\n    ) AS Legal,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN service_cm = 1 THEN 'Case Management'\n            ELSE NULL\n        END\n    ) AS \"CM\",\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_juv_divert = 1 THEN 'YIP'\n            ELSE NULL\n        END\n    ) AS YIP,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan = 1 THEN 'SCaN'\n            ELSE NULL\n        END\n    ) AS SCaN,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN cm_scan_outreach = 1 THEN 'SCaN Outreach'\n            ELSE NULL\n        END\n    ) AS \"SCaN_Outreach\",\n    GROUP_CONCAT( DISTINCT\n        CASE\n            WHEN hd = 1 THEN 'HD'\n            ELSE NULL\n        END\n    ) AS HD,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN rjcc = 1 THEN 'RJCC'\n            ELSE NULL\n        END\n    ) AS RJCC,\n    GROUP_CONCAT(DISTINCT\n        CASE\n            WHEN crws = 1 THEN 'CRwS'\n            ELSE NULL\n        END\n    ) AS CRwS,\n    GROUP_CONCAT(distinct\n        CASE\n            WHEN vp = 1 THEN 'VP'\n            ELSE NULL\n        END\n    ) AS VP\nFROM {self.table}\nWHERE service_legal = 1 OR service_cm = 1 OR cm_juv_divert = 1\n      OR cm_scan = 1 OR cm_scan_outreach = 1 OR hd = 1\n      OR rjcc = 1 OR crws = 1 OR vp = 1\nGROUP BY participant_id),\nconcat_services as (SELECT\n    participant_id,\n    CONCAT_WS(' + ',\n        Legal,\n        CM,\n        YIP,\n        SCaN,\n        SCaN_Outreach,\n        HD,\n        RJCC,\n        CRwS,\n        VP\n    ) AS concatenated_services\nFROM (services_row))\nselect concatenated_services, count(concatenated_services), count(concatenated_services)/(SELECT COUNT(*) FROM concat_services) as percentage \nfrom concat_services\ngroup by concatenated_services\norder by count(concatenated_services) desc'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.programs_rct_neighborhoods","title":"<code>programs_rct_neighborhoods()</code>","text":"<p>Returns a breakdown of RCT involvement by neighborhood</p> <p>SQL Equivalent:</p> <pre><code>select\n    count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n    count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n    count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n    count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n    count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n    count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom stints.classify_by_program;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def programs_rct_neighborhoods(self):\n'''\n        Returns a breakdown of RCT involvement by neighborhood\n        SQL Equivalent:\n            select\n                count(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\n                count(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,  \n                count(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\n                count(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\n                count(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\n                count(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\n            from stints.classify_by_program;\n        '''\nquery = f'''select\ncount(distinct case when program_type regexp \".*RCT.*\" then participant_id else null end) as Overall,\ncount(distinct case when program_type regexp \".*RCT,.*\" OR program_type = \"RCT\" OR program_type like \"%, RCT\" then participant_id else null end) as Lawndale,\ncount(distinct case when program_type regexp \".*RCT - BUILD.*\" then participant_id else null end) as Austin,\ncount(distinct case when program_type regexp \".*RCT - NLC.*\"  then participant_id else null end) as Little_Village,\ncount(distinct case when program_type regexp \".*RCT - Breakthrough.*\" then participant_id else null end) as East_Garfield_Park,\ncount(distinct case when program_type regexp \".*RCT - Target.*\" then participant_id else null end) as South_Side\nfrom {self.table}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.programs_service_tally","title":"<code>programs_service_tally(service_column)</code>","text":"<p>Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service</p> <p>Parameters:</p> Name Type Description Default <code>Service</code> <code>column</code> <p>the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")</p> required <p>SQL Equivalent: </p> <pre><code>select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>def programs_service_tally(self, service_column):\n'''\n    Meant for use with a stints.classify_by_program like table. Counts the number of clients receiving a given service\n    Parameters:\n        Service column: the the column to tally (\"service_legal\", \"service_cm\", \"cm_juv_divert\", \"cm_scan\", \"cm_scan_outreach\", \"hd\", \"hd_rct\", \"rjcc\", \"crws\", \"vp\", \"outreach\")\n    SQL Equivalent: \n        select COUNT(DISTINCT CASE WHEN hd = 1 THEN participant_id END) AS Count from stints.classify_by_program;\n    '''\nif service_column.lower() == \"outreach\":\nquery = f'''select count(distinct participant_id) from {self.table} where program_type like \"%outreach%\"'''\nelse:\nquery = f'''select COUNT(DISTINCT CASE WHEN {service_column} = 1 THEN participant_id END) AS Count from {self.table}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.programs_session_length","title":"<code>programs_session_length(cm_outreach='cm', grouped=False, timeframe=True)</code>","text":"<p>Finds the length of case management or outreach sessions</p> <p>Parameters:</p> Name Type Description Default <code>cm_outreach</code> <p>\"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"</p> <code>'cm'</code> <code>grouped(Bool)</code> <p>True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False</p> required <code>timeframe</code> <code>Bool</code> <p>whether to only count people who had at least one linkage between T1 and T2, defaults to True</p> <code>True</code> <p>SQL Equivalent:</p> <pre><code>select \n    avg(hours) * 60 as overall,\n    avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \nfrom stints.classify_by_program\njoin civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>def programs_session_length(self, cm_outreach = \"cm\", grouped = False, timeframe = True):\n'''\n    Finds the length of case management or outreach sessions\n    Parameters:\n        cm_outreach: \"cm\" returns case management sessions, while \"outreach\" returns outreach sessions, defaults to \"cm\"\n        grouped(Bool): True returns the number of sessions in assorted 15 minute intervals, while False finds the average length of sessions overall, and sessions excluding unsuccessful contact. Defaults to False\n        timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n    SQL Equivalent:\n        select \n            avg(hours) * 60 as overall,\n            avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful    \n        from stints.classify_by_program\n        join civicore.case_sessions using(participant_id) where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n    '''\nif cm_outreach == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nif grouped is False:\nquery = f'''select \n        avg(hours) * 60 as overall,\n     avg(case when hours &gt; 0  and (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') then hours else null end) * 60 as successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\nif grouped is True:\nif timeframe is True:  \nquery = f'''with hr_avg as (select \n    c.*,\n    case \n    when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n    when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n    when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n    when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n    when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n    when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n    when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n    when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n    when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n    when hours &gt; 2 then \"2+\"\n    end as session_length\nfrom {self.table}\njoin civicore.case_sessions c using(participant_id)\nwhere session_date BETWEEN {self.q_t1} and {self.q_t2} and session_casenote = {cm_outreach})\nselect session_length, count(session_length)\nfrom hr_avg\ngroup by session_length\norder by case when session_length = '0' then 1\n            when session_length = '0-.25' then 2\n            when session_length = '.26-.5' then 3\n            when session_length = '.51-.75' then 4\n            when session_length = '.76-1' then 5\n            when session_length = '1-1.25' then 6\n            when session_length = '1.26-1.5' then 7\n            when session_length = '1.51-1.75' then 8\n            when session_length = '1.76-2' then 9\n            when session_length = '2+' then 10\n            else 0\n            end asc'''\nelse: \nquery = f'''with hr_avg as (select \n    c.*,\n    case \n    when hours = 0 or (contact_type = 'Unsuccessful Attempt') then \"0\"\n    when hours &gt; 0 and hours &lt;= .25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"0-.25\"\n    when hours &gt;.25 and hours &lt;= .5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".26-.5\"\n    when hours &gt; 0.5 and hours &lt;= .75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".51-.75\"\n    when hours &gt; .75 and hours &lt;= 1  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \".76-1\"\n    when hours &gt; 1 and hours &lt;= 1.25  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1-1.25\"\n    when hours &gt;1.25 and hours &lt;= 1.5  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.26-1.5\"\n    when hours &gt; 1.5 and hours &lt;= 1.75  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.51-1.75\"\n    when hours &gt; 1.75 and hours &lt;= 2  and (contact_type IS NULL OR contact_type NOT LIKE 'Unsuccessful Attempt') then \"1.76-2\"\n    when hours &gt; 2 then \"2+\"\n    end as session_length\nfrom {self.table}\njoin civicore.case_sessions c using(participant_id)\nwhere session_casenote = {cm_outreach})\nselect session_length, count(session_length)\nfrom hr_avg\ngroup by session_length\norder by case when session_length = '0' then 1\n            when session_length = '0-.25' then 2\n            when session_length = '.26-.5' then 3\n            when session_length = '.51-.75' then 4\n            when session_length = '.76-1' then 5\n            when session_length = '1-1.25' then 6\n            when session_length = '1.26-1.5' then 7\n            when session_length = '1.51-1.75' then 8\n            when session_length = '1.76-2' then 9\n            when session_length = '2+' then 10\n            else 0\n            end asc'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.programs_session_tally","title":"<code>programs_session_tally(cm_outreach='cm')</code>","text":"<p>Counts successful and unsuccessful sessions among outreach or case managers</p> <p>Parameters:</p> Name Type Description Default <code>cm_outreach</code> <p>which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"</p> <code>'cm'</code> <p>SQL Equivalent:</p> <pre><code>select \n    COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \nfrom stints.classify_by_program\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>    def programs_session_tally(self, cm_outreach = \"cm\"):\n'''\n        Counts successful and unsuccessful sessions among outreach or case managers\n        Parameters:\n            cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n        SQL Equivalent:\n            select \n                COUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n                COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful    \n            from stints.classify_by_program\n            join civicore.case_sessions using(participant_id)\n            where (session_date BETWEEN '2023-08-01' and '2023-08-31') and session_casenote = \"Casenote\";\n        '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select \n\tCOUNT(DISTINCT CASE WHEN (hours = 0 OR indirect_type = 'Unsuccessful Attempt') THEN case_session_id END) AS unsuccessful,\n    COUNT(DISTINCT CASE WHEN hours &gt; 0 AND (indirect_type IS NULL OR indirect_type NOT LIKE 'Unsuccessful Attempt') THEN case_session_id END) AS successful\nfrom {self.table}\njoin civicore.case_sessions using(participant_id)\nwhere (session_date BETWEEN {self.q_t1} and {self.q_t2}) and session_casenote = {cm_outreach}'''\ndf = self.query_run(query)\nreturn df\n</code></pre>"},{"location":"tables_ref/#script.nice_sql.Queries.programs_sessions","title":"<code>programs_sessions(timeframe=True, cm_outreach='cm')</code>","text":"<p>Counts clients who have at least one recorded session with a case manager or outreach worker</p> <p>Parameters:</p> Name Type Description Default <code>timeframe</code> <code>Bool</code> <p>whether to only count people who had at least one linkage between T1 and T2, defaults to True</p> <code>True</code> <code>cm_outreach</code> <p>which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"</p> <code>'cm'</code> <p>SQL Equivalent: </p> <pre><code>select count(distinct participant_id) from stints.classify_by_program \njoin civicore.case_sessions using(participant_id) \nwhere session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n</code></pre> Source code in <code>script\\nice_sql.py</code> <pre><code>def programs_sessions(self, timeframe = True, cm_outreach = \"cm\"):\n'''\n    Counts clients who have at least one recorded session with a case manager or outreach worker\n    Parameters:\n        timeframe (Bool): whether to only count people who had at least one linkage between T1 and T2, defaults to True\n        cm_outreach: which type of session to count. \"cm\" returns case management sessions, \"outreach\" returns outreach sessions. defaults to \"cm\"\n    SQL Equivalent: \n        select count(distinct participant_id) from stints.classify_by_program \n        join civicore.case_sessions using(participant_id) \n        where session_casenote = \"Casenote\" and session_date BETWEEN '2023-08-01' and '2023-08-31';\n    '''\nif cm_outreach.lower() == \"cm\":\ncm_outreach = f'\"Casenote\"'\nif cm_outreach.lower() == \"outreach\":\ncm_outreach = f'\"Mentoring Session\"'\nquery = f'''select count(distinct participant_id) from {self.table} join civicore.case_sessions using(participant_id) where session_casenote = {cm_outreach}'''\nif timeframe is True:\nquery = self.query_modify(str(query), f'''and session_date BETWEEN {self.q_t1} and {self.q_t2}''')\ndf = self.query_run(query)\nreturn df\n</code></pre>"}]}